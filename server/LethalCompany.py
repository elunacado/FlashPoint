# -*- coding: utf-8 -*-
"""FlashPoint_V2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1eRMVu3LGsCdgXBEDDPT7qwMTLSxZgqt2

# Mesa + Libraries
"""

#!pip install mesa==2.3.1 --quiet

# Importamos las clases que se requieren para manejar los agentes (Agent) y su entorno (Model).
from mesa import Agent, Model

# Usamos ''MultiGrid'' para representar una cuadrícula donde cada celda puede contener como máximo un agente.
from mesa.space import MultiGrid

# ''DataCollector'' nos permite recolectar y almacenar datos en cada paso de la simulación para su análisis posterior.
from mesa.datacollection import DataCollector

# Con ''RandomActivation'', activamos a todos los agentes en cada paso.
from mesa.time import RandomActivation

# Importamos cityblock para calcular la distancia Manhattan entre dos puntos.
from scipy.spatial.distance import cityblock

# Usamos matplotlib para generar animaciones y visualizar el progreso de la simulación en cada paso.
# %matplotlib inline
import matplotlib
import matplotlib.pyplot as plt
import matplotlib.animation as animation
from matplotlib.colors import ListedColormap
plt.rcParams["animation.html"] = "jshtml"
matplotlib.rcParams['animation.embed_limit'] = 2**128

# Importamos los siguientes paquetes para el mejor manejo de valores numéricos.
import numpy as np
import pandas as pd
import random

# ''seaborn'' nos permite crear gráficos estadísticos.
# import seaborn as sns

# Importamos paquetes adicionales para medir el tiempo de ejecución del algoritmo.
import time
import datetime
import json
"""#EmployeeAgent"""

class EmployeeAgent(Agent):
    """Clase que representa a un empleado que salva víctimas en el edificio de Lethal Company."""

    def __init__(self, id, model):
        """
        Inicializa las propiedades del agente.
        - id: Identificador único del agente.
        - model: Referencia al modelo al que pertenece el agente.
        """
        super().__init__(id, model)
        self.ap = 4  # Puntos de acción disponibles
        self.carrying_victim = False  # Estado de transporte de víctima
        self.finished_turn = False  # Estado del turno del agente
        self.next_cell = None  # Próxima celda a la que se moverá el agente
        self.remaining_AP = 0 # Puntos de acción restantes

    def step(self):
        """
        Define el comportamiento del agente en cada paso del modelo.
        Solo actúa si es su turno y evalúa si debe realizar una acción o finalizar su turno.
        """

        # Verifica si es el turno del agente.
        if self.model.turn == self.unique_id:
            self.finished_turn = False

            # Reinicia el objetivo al inicio del turno.
            self.goal = None

            # Realiza una acción si tiene puntos de acción disponibles y no ha terminado su turno.
            if self.ap >= 1 and not self.finished_turn:
                self.perform_single_action()

            # Finaliza el turno si no tiene puntos de acción o ha cumplido su objetivo.
            if self.ap == 0 or self.finished_turn:
                self.end_turn()

    def perform_single_action(self):

        """
        Realiza una acción simple, como extinguir goo o buscar un objetivo.
        """

        # Verifica si alcanzó su objetivo antes de realizar una acción.
        self.check_reached_goal()

        if not self.finished_turn:
            # Si hay goo o droplets en la celda actual, lo extingue.
            if self.model.threat_markers[self.pos] in [1, 2]:
                self.extinguish()

            else:
                # Busca goo/droplets en las celdas vecinas.
                neighbor_positions = self.model.grid.get_neighborhood(self.pos, moore=False, include_center=False)

                # Indica si el agente extinguió algo.
                self.extinguished = False

                # Indica que el agente se movió aleatoriamente
                self.moved = False

                # Busca vecinos válidos.
                valid_neighbors = self.looking_for_valid_neighbours()

                for valid_neighbor_pos in valid_neighbors:
                    x, y = valid_neighbor_pos
                    # Si encuentra goo o droplets en la celda vecina, lo extingue.
                    if self.model.threat_markers[(x, y)] in [1, 2]:
                        self.extinguish((x, y))
                        self.extinguished = True
                        break

                # Si no extinguió nada, define un objetivo y se dirige a él.
                if not self.extinguished:

                    # Si lleva una víctima, busca la salida más cercana; de lo contrario, busca una víctima.
                    self.goal = 16 if self.carrying_victim else 1
                    goal_position = self.search_goal_position(self.goal)

                    if goal_position:
                        self.go_to_goal_position(goal_position)
                        self.check_reached_goal()
                    else:
                        self.move_random()
                    self.moved = True

                # Finalizar el turno si no hay más acciones posibles
                if self.ap <= 0 or self.finished_turn == True or (not self.extinguished and not self.moved):
                    self.finished_turn = True

    def move_random(self):
        # Busca vecinos válidos.
        valid_neighbors = self.looking_for_valid_neighbours()

        # Escoge un vecino válido aleatorio que no sea (0,0).
        valid_neighbors = [pos for pos in valid_neighbors if pos != (0, 0)]

        if valid_neighbors:
            # Selecciona un vecino aleatorio.
            target_position = random.choice(valid_neighbors)

            self.move_agent_to(target_position)  # Mueve al agente a la posición seleccionada.

        else:
            # Si no encuentra vecinos válidos, termina su turno.
            self.finished_turn = True

    def looking_for_valid_neighbours(self):
        """
        Busca vecinos válidos donde no haya paredes o puertas que impidan adyacencias.
        """
        # Lista para almacenar los vecinos válidos.
        valid_neighbors = []

        # Obtiene las posiciones vecinas.
        neighbor_positions = self.model.grid.get_neighborhood(self.pos, moore=False, include_center=False)

        for neighbor_pos in neighbor_positions:
            x, y = neighbor_pos

            # Verificar si hay una puerta cerrada entre la celda actual y la vecina.
            current_pos = self.pos
            door = tuple(sorted([current_pos, neighbor_pos]))
            if door in self.model.door_states and self.model.door_states[door] == "closed":
                continue  # Puerta cerrada, no es vecino válido.

            # Verifica si hay una pared entre la celda actual y la vecina.
            wall = tuple(sorted([current_pos, neighbor_pos]))
            if wall in self.model.wall_states:
                wall_state = self.model.wall_states[wall]
                if wall_state in ["okay", "damaged"]:
                    continue  # Hay una pared, no es vecino válido.

            # Si pasa las verificaciones, es un vecino válido.
            valid_neighbors.append(neighbor_pos)

        return valid_neighbors

    def end_turn(self):
        """
        Finaliza el turno del agente, restablece puntos de acción y pasa al siguiente agente.
        """
        # Verifica si el juego debe terminar. Si el juego ha terminado, no continúa.
        self.model.end_game()
        if not self.model.running:
          return

        # Avanza la cantidad de marcadores de riesgo.
        self.model.advance_goo()

        # Revisar efectos secundarios.
        self.model.check_secondary_effects()
        self.knocked_down()

        # Reabastece puntos de interés si es necesario.
        self.model.replenish_pois()

        # Restablece los puntos de acción para el siguiente turno.
        self.remaining_AP = self.ap
        self.remaining_AP = min(self.ap, 4)  # Limitar a 4 AP extras máximo

        self.ap = 4 + self.remaining_AP

        self.remaining_AP = 0
        self.finished_turn = False

        # Verifica si el juego debe terminar. Si el juego ha terminado, no continúa.
        self.model.end_game()
        if not self.model.running:
          return

        # Pasa el turno al siguiente agente.
        self.model.turn += 1

    def extinguish(self, position=None):
        """
        Extingue goo o droplets en una celda específica.
        """
        if position is None:
            position = self.pos

        # Si es goo, cambia de goo a droplet.
        if self.model.threat_markers[position] == 2:
            self.model.threat_markers[position] = 1
            self.ap -= 1

        # Si es droplet, cambia a vacío.
        elif self.model.threat_markers[position] == 1:
            self.model.threat_markers[position] = 0
            self.model.current_threat_markers -= 1  # Actualizar el contador
            self.ap -= 1
            
        self.check_if_turn_finished()

    def check_reached_goal(self):
        """
        Verifica si el agente ha alcanzado su objetivo:
        - Salvar a una víctima.
        - Detectar un punto de interés (POI).
        """
        if self.carrying_victim and self.model.entry_points_location[self.pos] == 16:
            # Si lleva una víctima y llega a la salida.
            self.model.saved_victims += 1
            self.model.poi_real_victim -= 1
            self.model.poi_total_count -= 1
            self.model.poi_in_building -= 1

            self.carrying_victim = False
            self.finished_turn = True
        elif not self.carrying_victim and self.model.poi_placement[self.pos] in [3, 4]:
            # Si encuentra un POI válido.
            self.reveal_poi()

    def reveal_poi(self):
        """
        Revela el Punto de Interés (POI) en la celda actual del agente.
        Si el POI es una falsa alarma, se elimina y se actualizan los contadores correspondientes.
        Si el POI representa a una víctima, el agente la recoge.
        """
        if self.model.poi_placement[self.pos] == 3:  # Si el POI es una falsa alarma.
            self.model.poi_placement[self.pos] = 0  # Elimina el POI de la celda.
            self.model.poi_false_alarm -= 1 # Reduce el contador de falsas alarmas.
            self.model.poi_total_count -= 1 # Reduce el total de POIs.
            self.model.poi_in_building -= 1 # Reduce el total de POIs dentro del edificio.
        elif self.model.poi_placement[self.pos] == 4 and not self.carrying_victim:
            # Si el POI representa a una víctima y el agente no está transportando una.
            self.carrying_victim = True # El agente recoge a la víctima.
            self.model.poi_placement[self.pos] = 0

    def search_goal_position(self, goal):
        """
        Busca la posición más cercana al objetivo indicado:
        - goal = 1: Busca un POI (valores 3 o 4) más cercano.
        - goal = 16: Busca la salida más cercana.
        - si no hay posición objetivo válida, se mueve aleatoriamente para apaagr fuego.**
        Retorna la posición objetivo más cercana.
        """

        # Buscar POIs más cercanos (víctimas o falsas alarmas).
        if self.goal == 1:
            min_distance = float("inf")
            nearest_position = None
            for x in range(self.model.grid.width):
                for y in range(self.model.grid.height):
                    if self.model.poi_placement[(x, y)] in [3, 4]:
                        # Calcula distancia Manhattan.
                        distance = cityblock(self.pos, (x, y))
                        if distance < min_distance:
                            min_distance = distance
                            nearest_position = (x, y)

        # Buscar la salida más cercana
        if self.goal == 16:
            min_distance = float("inf")
            nearest_position = None
            for x in range(self.model.grid.width):
                for y in range(self.model.grid.height):
                    if self.model.entry_points_location[(x, y)] == goal:
                        # Calcula distancia Manhattan.
                        distance = cityblock(self.pos, (x, y))
                        if distance < min_distance:
                            min_distance = distance
                            nearest_position = (x, y)
        return nearest_position

    def go_to_goal_position(self, goal_position):
        """
        Mueve al agente hacia la posición objetivo especificada.
        Considera paredes y puertas como posibles obstáculos.
        """
        goal_x, goal_y = goal_position
        current_x, current_y = self.pos

        # Determina la dirección del movimiento hacia el objetivo.
        if current_x < goal_x:
            new_pos = (current_x + 1, current_y)
        elif current_x > goal_x:
            new_pos = (current_x - 1, current_y)
        elif current_y < goal_y:
            new_pos = (current_x, current_y + 1)
        elif current_y > goal_y:
            new_pos = (current_x, current_y - 1)
        else:
            # Si ya está en la posición objetivo, marca el turno como finalizado.
            self.finished_turn = True
            return

        # Intenta moverse hacia la nueva posición verificando obstáculos.
        self.move_to_new_position(new_pos)

    def move_to_new_position(self, new_position):
        """
        Intenta mover al agente a la nueva posición indicada.
        Considera si hay puertas o paredes entre la celda actual y la nueva posición.
        """
        current_x, current_y = self.pos
        new_x, new_y = new_position

        # Verificar si hay una puerta entre la posición actual y la nueva posición.
        door = tuple(sorted([(current_x, current_y), (new_x, new_y)]))
        has_door = door in self.model.door_states

        if has_door:
            door_state = self.model.door_states[door]
            if door_state == "closed":
                # Si la puerta está cerrada, intenta abrirla.
                if self.ap >= 1:
                    self.open_door(door)
                else:
                    self.finished_turn = True
            elif door_state == "open" or door_state == "removed":
                # Si la puerta está abierta, se mueve a través de ella.
                self.move_agent_to(new_position)
        else:
            # Verifica si hay una pared entre la celda actual y la nueva posición.
            wall = tuple(sorted([(current_x, current_y), (new_x, new_y)]))
            has_wall = wall in self.model.wall_states

            if has_wall:
                wall_state = self.model.wall_states[wall]
                if wall_state == "destroyed":
                    # Si la pared está destruida, se mueve a través de ella.
                    self.move_agent_to(new_position)
                else:
                    # Si la pared está intacta o dañada, intenta dañarla si es posible.
                    if self.model.damage_counter <= 6:
                        # Mover aleatoriamente
                        self.move_random()
                        return
                    elif self.ap >= 2:
                        self.damage_wall(wall)
                    else:
                        self.finished_turn = True
            else:
                # Si no hay paredes ni puertas, se mueve directamente.
                self.move_agent_to(new_position)

    def open_door(self, door):
        """
        Abre una puerta cerrada entre dos celdas.
        - Actualiza el estado de la puerta a "open".
        - Reduce los puntos de acción (AP) del agente en 1.
        """
        self.model.door_states[door] = "open"
        self.ap -= 1

    def damage_wall(self, wall_position):
        """
        Daña o destruye una pared en la posición especificada.
        - Si la pared está en estado "okay", la daña.
        - Si la pared ya está dañada, la destruye.
        - Actualiza los contadores y el estado de las paredes.
        """

        # Obtener el estado actual de la pared
        wall_state = self.model.wall_states[wall_position]

        if wall_state == "okay":
            # Si la pared está intacta, se daña.
            self.model.wall_states[wall_position] = "damaged"
            self.ap -= 2
            self.model.damage_counter -= 1
            
        elif wall_state == "damaged":
            # Si la pared ya está dañada, se destruye.
            self.model.wall_states[wall_position] = "destroyed"
            self.ap -= 2
            self.model.damage_counter -= 1
            
            # Determinar qué pared fue destruida.
            (pos1, pos2) = wall_position
            x1, y1 = pos1
            x2, y2 = pos2

            # Actualiza la matriz de paredes para reflejar el estado destruido.
            self.model.update_wall_matrix(wall_position, "destroyed")

        # Si la pared ya está destruida, no realiza ninguna acción.

    def move_agent_to(self, new_position):
        """
        Mueve al agente a una nueva posición dentro de la cuadrícula.
        - Si la nueva posición es inválida, bloquea el movimiento.
        - Reduce los puntos de acción (AP) según el estado del agente.
        """

        # Evita que el agente se mueva a la posición (0, 0).
        if new_position == (0, 0):
            self.finished_turn = True
            return

        # Verifica si la nueva posición está dentro de los límites de la cuadrícula.
        if (0 <= new_position[0] < self.model.grid.width and
            0 <= new_position[1] < self.model.grid.height):
            # Mueve al agente a la nueva posición.
            self.model.grid.move_agent(self, new_position)

            # Reduce los puntos de acción (AP) según el estado del agente.
            if not self.carrying_victim:
                self.ap -= 1
            elif self.carrying_victim and self.ap >=2:
                self.ap -= 2
            else:
                # Finaliza el turno si no hay suficientes AP
                self.finished_turn = True
        else:
            # Si la nueva posición está fuera de los límites, bloquea el movimiento.
            self.finished_turn = True

    def knocked_down(self):
        """Revisar si algún empleado o víctima resultó herido al estar en una celda con goo."""
        # Iterar sobre los agentes en el modelo
        for agent in self.model.schedule.agents:
            # Verificar si el agente es un EmployeeAgent
            if isinstance(agent, EmployeeAgent):
                x, y = agent.pos  # Obtener la posición del empleado
                # Verificar si la celda contiene goo
                if self.model.threat_markers[x, y] == 2:
                    # Manejar el efecto de goo sobre el empleado
                    # Si el agente lleva una víctima, se pierde
                    if agent.carrying_victim:
                        self.model.poi_total_count -= 1
                        self.model.poi_real_victim -= 1
                        agent.carrying_victim = False
                        self.model.lost_victims += 1

                    # Terminar el turno del agente
                    agent.finished_turn = True

                    # Eliminar al agente del grid
                    self.model.grid.remove_agent(agent)

                    # Elegir un punto de entrada aleatorio
                    random_entry_point = self.random.choice(self.model.entry_points)

                    # Colocar al agente en el punto de entrada
                    self.model.grid.place_agent(agent, random_entry_point)
                    agent.pos = random_entry_point  # Actualizar posición del agente
                    
        # Revisar si hay POIs en celdas con goo
        for x in range(self.model.height):
            for y in range(self.model.width):
                # Si la celda contiene goo y un POI
                if self.model.threat_markers[x, y] == 2 and self.model.poi_placement[x, y] in [3, 4]:
                    poi_type = self.model.poi_placement[x, y]
                    self.model.poi_placement[x, y] = 0  # Eliminar el POI del grid
                    self.model.poi_total_count -= 1
                    self.model.poi_in_building -= 1

                    if poi_type == 4:  # Si era una víctima
                        self.model.poi_real_victim -= 1
                        self.model.lost_victims += 1
                    elif poi_type == 3:  # Si era una falsa alarma
                        self.model.poi_false_alarm -= 1

    def check_if_turn_finished(self):
        """
        Verifica si el turno del agente debe finalizar.
        - El turno termina si los puntos de acción (AP) se agotan o si ya se marcó como finalizado.
        """

        if self.ap <= 0 or self.finished_turn:
            self.end_turn()

"""# LootBugAgent"""

class LootBugAgent(Agent):
    """Clase que representa a un Lootbug. Este se encarga de mover a los POIs para elevar el juego."""
    def __init__(self, id, model):
        super().__init__(id, model)
        """
        Inicializa las propiedades del agente LootBug.
        - id: Identificador único del agente.
        - model: Referencia al modelo.
        """
        self.cargando_poi = False  # Indica si el agente está cargando un POI.
        self.poi_cargado = None  # Almacena el tipo de POI que lleva cargado.
        self.state = "capturar_poi"  # Estado inicial del agente.

    def teleport(self, target):
        """Teletransportar al agente a una posición específica."""
        self.model.grid.move_agent(self, target)

    def step(self):
        """
        Define las acciones del LootBug en su turno, basado en su estado actual.
        Los estados incluyen capturar un POI, colocar el POI y regresar al origen.
        """
        if self.model.turn == self.unique_id:
            # Verificar si el juego ha terminado antes de proceder
            self.model.end_game()
            if not self.model.running:
                return

            if self.state == "capturar_poi":
                """
                Estado para buscar y recoger un POI.
                - Encuentra un POI disponible en la cuadrícula.
                - Se teletransporta al POI y lo recoge.
                """
                poi_positions = [(x, y) for x in range(self.model.height) for y in range(self.model.width)
                                if self.model.poi_placement[x, y] in [3, 4]]

                # Si hay POIs disponibles.
                if poi_positions:
                    self.target_poi = self.random.choice(poi_positions)
                    self.teleport(self.target_poi)

                    # Recoger el POI.
                    x, y = self.pos
                    self.poi_cargado = self.model.poi_placement[x, y]
                    self.model.poi_placement[x, y] = 0
                    self.state = "colocar_poi"
                else:
                    # Finaliza el turno si no hay POIs.
                    self.end_turn()

            elif self.state == "colocar_poi":
                """
                Estado para colocar el POI en una celda vacía.
                - Busca una celda libre y se teletransporta a ella.
                - Coloca el POI en la nueva posición.
                """
                valid_cells = [(x, y) for x in range(self.model.height) for y in range(self.model.width)
                              if self.model.poi_placement[x, y] == 0  # Celda libre en el grid de POIs
                              and not self.model.grid.get_cell_list_contents((x, y))]  # Celda libre en el grid de agentes
                if valid_cells:
                    # Si hay celdas válidas.
                    new_position = self.random.choice(valid_cells) # Selecciona una celda aleatoria.
                    nx, ny = new_position

                    # Verifica si la celda seleccionada contiene marcadores de amenaza y los elimina.
                    if self.model.threat_markers[nx, ny] in [2, 1]:
                      self.model.threat_markers[nx, ny] = 0
                      self.model.current_threat_markers -= 1  # Actualizar el contador

                    self.teleport(new_position)  # Se teletransporta a la celda seleccionada.
                    self.model.poi_placement[nx][ny] = self.poi_cargado # Deja el POI.
                    self.poi_cargado = None # Vacía su carga de POI.
                    self.state = "volver_origen" # Cambia al estado para regresar al origen.

            elif self.state == "volver_origen":
                """
                Estado para regresar al origen (0, 0).
                - Se teletransporta al origen.
                - Reinicia el ciclo volviendo al estado inicial.
                """
                self.teleport(self.model.lootbug_nest)
                self.state = "capturar_poi"  # Reiniciar ciclo
                self.end_turn()

    def end_turn(self):
        """
        Finaliza el turno del LootBug.
        - Incrementa el turno del modelo.
        - Si supera el total de agentes, reinicia el contador de turnos.
        """
        self.model.turn += 1
        if self.model.turn >= len(self.model.schedule.agents):
            # Reinicia el turno si sobrepasa el total
            self.model.turn = 0

"""# Grid 1 - Puertas y puntos de entrada"""

def get_grid_doors_entries(model):
    """Crea una representación de las puertas y puntos de entrada del edificio."""
    # Copiar la matriz base (puertas) para superponer información adicional
    combined_grid = np.copy(model.doors)

    # Superponer los puntos de entrada en la matriz combinada
    for x, y in model.entry_points:
        combined_grid[x, y] = max(combined_grid[x, y], 16)

    # Superponer el lootbug nest en la matriz combinada
    if hasattr(model, "lootbug_nest"):  # Verifica que el atributo lootbug_nest exista
        nest_x, nest_y = model.lootbug_nest
        combined_grid[nest_x, nest_y] = max(combined_grid[nest_x, nest_y], 32)  # Usamos 32 para lootbug nest



    return combined_grid

"""# Grid 2 - Paredes"""

def get_grid_walls(model):
    """Crea una representación de las paredes del edificio."""
    grid = model.walls.copy()

    return grid

"""#Grid 3 - POI"""

def get_grid_poi(model):
    """Crea una representación de los POI en el edificio."""
    grid = model.poi_placement.copy()

    return grid

"""#Grid 4 - Threatmarkers



"""

def get_grid_threat_markers(model):
    """Crea una representación de los threath markers en el edificio."""
    grid = model.threat_markers.copy()

    return grid

"""#Grid 5 - Agents"""

def get_grid(model):
    """Crea una representación de los agentes en el edificio."""
    grid = np.zeros((model.grid.width, model.grid.height))

    # Iterar sobre todas las celdas del grid
    for content, (x, y) in model.grid.coord_iter():
        for agent in content:
            if isinstance(agent, EmployeeAgent):
                grid[x][y] = 6  # Representar el agente con el valor 6
            if isinstance(agent, LootBugAgent):
                grid[x][y] = 7  # Representar el agente con el valor 7


    return grid

"""#Model"""

class ModeloEdificio(Model):
    """Modelo del edificio Lethal company."""
    def __init__(self, wall_data, poi_data, goo_data, doors_data, entry_points_data):
        super().__init__()

        # Agentes
        self.turn = 0
        self.employee_agents = 6
        self.lootbug_agents = 1
        self.schedule = RandomActivation(self)

        # Dimensiones del modelo
        self.height = 6
        self.width = 8

        # Grid del modelo
        self.grid = MultiGrid(self.height, self.width, torus=False)
        self.running = True
        self.steps = 0

        # Variables del modelo
        self.max_threat_markers = 32
        self.current_threat_markers = 0
        self.poi_total_count = 15
        self.poi_false_alarm = 5
        self.poi_real_victim  = 10
        self.poi_in_building = 0

        self.damage_counter = 24
        self.door_markers = 8
        self.start_point = 4
        self.saved_victims = 0
        self.lost_victims = 0
        self.collapsed_building = False
        self.lootbug_nest = (0,0)

        # Diccionario para rastrear estados de POIs ('closes' o 'open').
        self.poi_states = {}

        # Diccionario para rastrear estados de puertas.
        # Tuplas de posiciones adyacentes, y los valores son 'closed' o 'open'.
        self.door_states = {}

        # Diccionario para rastrear estados de paredes.
        # Clave: ((x1, y1), (x2, y2)), Valor: "okay", "damaged", "destroyed".
        self.wall_states = {}

        # Matrices para representar el estado del edificio.
        self.entry_points_location = np.zeros((self.height, self.width))

        # Paredes: cada celda contiene un entero donde cada bit representa una dirección:
        # Bit 0: Arriba, Bit 1: Derecha, Bit 2: Abajo, Bit 3: Izquierda
        self.walls = np.zeros((self.height, self.width), dtype=int)
        self.doors = np.zeros((self.height, self.width), dtype=int)

        # Matrices para objetos
        self.threat_markers = np.zeros((self.height, self.width)) # goo y droplets
        self.poi_placement = np.zeros((self.height, self.width)) # POIs

        # Colocar elementos iniciales
        self.place_walls(wall_data)    # Colocar paredes
        self.place_poi(poi_data)      # Colocar los POIs respetando el número por tipo
        self.place_goo(goo_data)      # Colocar el goo
        self.place_doors(doors_data)    # Colocar puertas
        self.place_start_point(entry_points_data)  # Colocar puntos de entradas

        # Crear y colocar agentes
        self.place_employees()
        self.place_lootbug()

        # Inicializar recolector de datos
        self.datacollector = DataCollector(
            model_reporters={
                "Grid 1 Puertas y salidas": get_grid_doors_entries,
                "Grid 2 Paredes": get_grid_walls,
                "Grid 3 POI": get_grid_poi,
                "Grid 4 Threatmarkers": get_grid_threat_markers,
                "Grid 5 Agents": get_grid,
                "Estados Paredes": lambda model: model.wall_states,
                "Estados Puertas": lambda model: model.door_states,
                "Steps": lambda model: model.steps,
                "Edificio colapsado": lambda model: model.collapsed_building,
                "Victimas salvadas": lambda model: model.saved_victims,
                "Victimas perdidas": lambda model: model.lost_victims,
            }
        )

    def place_lootbug(self):
        """Coloca agentes en puntos de entrada seleccionados aleatoriamente."""
        for i in range(self.lootbug_agents):

            # Crear el agente
            agent = LootBugAgent(self.employee_agents, self)

            # Colocar el agente en el punto de entrada
            self.grid.place_agent(agent, self.lootbug_nest)

            # Agregar el agente al schedule
            self.schedule.add(agent)

    def place_employees(self):
        """Coloca agentes en puntos de entrada seleccionados aleatoriamente."""
        for i in range(self.employee_agents):
            # Seleccionar un punto de entrada aleatorio
            random_entry_point = self.random.choice(self.entry_points)

            # Crear el agente
            agent = EmployeeAgent(i, self)

            # Colocar el agente en el punto de entrada
            self.grid.place_agent(agent, random_entry_point)

            # Agregar el agente al schedule
            self.schedule.add(agent)

    def place_walls(self, wall_data):
        """Coloca paredes en posiciones específicas y asigna sus estados correctamente según la matriz dada."""
        for i in range(self.height):
            for j in range(self.width):
                wall_value = int(wall_data[i][j], 2)  # Convertir binario a entero
                self.walls[i, j] = wall_value  # Guardar el valor decimal de las paredes

                # Definir las paredes basadas en los bits (arriba, derecha, abajo, izquierda).
                if wall_value & 8:  # Pared arriba (bit 3)
                    if i > 0:
                        wall_pos = ((i, j), (i - 1, j))
                        self.wall_states[tuple(sorted(wall_pos))] = "okay"

                if wall_value & 4:  # Pared derecha (bit 2)
                    if j < self.width - 1:
                        wall_pos = ((i, j), (i, j + 1))
                        self.wall_states[tuple(sorted(wall_pos))] = "okay"

                if wall_value & 2:  # Pared abajo (bit 1)
                    if i < self.height - 1:
                        wall_pos = ((i, j), (i + 1, j))
                        self.wall_states[tuple(sorted(wall_pos))] = "okay"

                if wall_value & 1:  # Pared izquierda (bit 0)
                    if j > 0:
                        wall_pos = ((i, j), (i, j - 1))
                        self.wall_states[tuple(sorted(wall_pos))] = "okay"

    def place_poi(self, poi_data):
        """Coloca POIs en posiciones específicas respetando el número por tipo y actualiza las variables."""

        # Crear lista de tipos de POIs respetando los contadores.
        poi_types = (
            [3] * self.poi_false_alarm +  # POIs falsos
            [4] * self.poi_real_victim    # POIs reales
        )

        # Barajar aleatoriamente los tipos de POIs.
        self.random.shuffle(poi_types)

        # Seleccionar solo los necesarios para las posiciones disponibles.
        selected_poi_types = poi_types[:len(poi_data)]

        # Asignar tipos de POIs a las posiciones disponibles.
        for (x, y, poi_type), poi_val in zip(poi_data, selected_poi_types):
            # Ajustar índices para comenzar desde 0
            adjusted_x, adjusted_y = x - 1, y - 1

            # Validar que las posiciones ajustadas estén dentro de los límites.
            if 0 <= adjusted_x < self.height and 0 <= adjusted_y < self.width:
                # Determinar el valor de POI basado en tipo ('v' -> verdadero, 'f' -> falso).
                value = 4 if poi_type == 'v' else 3
                self.poi_placement[adjusted_x][adjusted_y] = value

                # Inicializar estado como "cerrado".
                self.poi_states[(adjusted_x, adjusted_y)] = "closed"
                self.poi_in_building += 1

    def place_goo(self, goo_data):
        """Coloca goo en posiciones específicas basadas en los datos proporcionados con ajuste de índice."""
        for x, y in goo_data:
            # Ajustar índices para comenzar desde 0
            adjusted_x, adjusted_y = x - 1, y - 1

            # Asegúrate de que las posiciones ajustadas estén dentro de los límites.
            if 0 <= adjusted_x < self.height and 0 <= adjusted_y < self.width:
                if self.threat_markers[adjusted_x][adjusted_y] == 0:  # Solo colocar si la celda está vacía
                    self.threat_markers[adjusted_x][adjusted_y] = 2  # Representar el goo con un valor de 2
                    self.current_threat_markers += 1  # Incrementa el contador de fichas en el tablero
                    

    def place_doors(self, doors_data):
        """Coloca puertas en posiciones específicas basadas en los datos proporcionados con ajuste de índice."""
        for row1, col1, row2, col2 in doors_data:

            # Ajustar índices para comenzar desde 0
            adjusted_row1, adjusted_col1 = row1 - 1, col1 - 1
            adjusted_row2, adjusted_col2 = row2 - 1, col2 - 1

            # Validar que las posiciones estén dentro de los límites
            if (
                0 <= adjusted_row1 < self.height and
                0 <= adjusted_col1 < self.width and
                0 <= adjusted_row2 < self.height and
                0 <= adjusted_col2 < self.width
            ):
                # Marcar las puertas en la matriz doors
                if adjusted_row1 == adjusted_row2:  # Puerta entre columnas en la misma fila
                    self.doors[adjusted_row1, adjusted_col1] |= 4
                    self.doors[adjusted_row2, adjusted_col2] |= 1
                elif adjusted_col1 == adjusted_col2:  # Puerta entre filas en la misma columna
                    self.doors[adjusted_row1, adjusted_col1] |= 2
                    self.doors[adjusted_row2, adjusted_col2] |= 8

                # Crear una tupla de posiciones ordenadas
                pos1 = (adjusted_row1, adjusted_col1)
                pos2 = (adjusted_row2, adjusted_col2)
                door = tuple(sorted([pos1, pos2]))

                # Inicializar el estado de la puerta como "closed"
                self.door_states[door] = "closed"

    def place_start_point(self, entry_points_data):
        """Coloca puntos de entrada en posiciones específicas y las guarda en una lista."""
        self.entry_points = []  # Lista para almacenar puntos de entrada
        for x, y in entry_points_data:
            # Ajustar índices para comenzar desde 0
            adjusted_x, adjusted_y = x - 1, y - 1
            # Asegúrate de que las posiciones ajustadas estén dentro de los límites
            if 0 <= adjusted_x < self.height and 0 <= adjusted_y < self.width:
                self.entry_points_location[adjusted_x][adjusted_y] = 16  # Representar el punto de entrada con un valor de 16
                self.entry_points.append((adjusted_x, adjusted_y))  # Agregar punto de entrada a la lista

    def replenish_pois(self):
        """Repone los POIs en el edificio."""
        while self.poi_in_building < min(3, self.poi_total_count):
            # Verificar si quedan POIs disponibles
            if self.poi_false_alarm == 0 and self.poi_real_victim == 0:
                # No quedan más POIs para colocar.
                break

            # Elegir un espacio aleatorio en el grid
            x = self.random.randint(0, self.height - 1)
            y = self.random.randint(0, self.width - 1)

            # Verificar las condiciones para colocar un POI
            if self.poi_placement[x, y] == 0:

                if self.threat_markers[x, y] in [2, 1]:
                    self.threat_markers[x, y] = 0
                    self.current_threat_markers -= 1  # Decrementar el contador de threat markers

                # Elegir el nuevo POI (aleatoriamente entre 3 y 4)
                poi_types = (
                    [3] * self.poi_false_alarm +  # POIs falsos
                    [4] * self.poi_real_victim    # POIs reales
                )

                # Barajar aleatoriamente los tipos de POIs
                new_poi = self.random.choice(poi_types)

                # Verificar si hay un agente en la celda
                cell_agents = self.grid.get_cell_list_contents((x, y))
                employee_present = any(isinstance(agent, EmployeeAgent) for agent in cell_agents)

                if employee_present:
                    self.poi_placement[x, y] = new_poi
                    self.poi_in_building += 1
                    if new_poi == 3:  # Falsa alarma
                        self.poi_placement[x, y] = 0
                        self.poi_false_alarm -= 1
                        self.poi_total_count -= 1
                        self.poi_in_building -= 1
                    # else es 4: Víctima
                else:
                    # Colocar el nuevo POI en la celda
                    self.poi_placement[x, y] = new_poi
                    self.poi_in_building += 1

    def can_place_threat_marker(self):
        """
        Verifica si se puede colocar otro threat marker (goo o droplet) en el tablero.
        """
        return self.current_threat_markers <= self.max_threat_markers

    def update_wall_matrix(self, wall_position, state):
        """
        Actualiza la matriz de paredes del modelo para reflejar el estado actual.
        """
        (pos1, pos2) = wall_position
        x1, y1 = pos1
        x2, y2 = pos2

        if state == "destroyed":
            # Determinar la dirección de la pared a eliminar
            if x1 == x2:  # Pared horizontal
                if y1 < y2:  # pos1 está a la izquierda de pos2
                    self.walls[x1, y1] &= ~4  # Elimina la pared derecha (bit 2) de pos1
                    self.walls[x2, y2] &= ~1  # Elimina la pared izquierda (bit 0) de pos2
                else:  # pos1 está a la derecha de pos2
                    self.walls[x1, y1] &= ~1  # Elimina la pared izquierda (bit 0) de pos1
                    self.walls[x2, y2] &= ~4  # Elimina la pared derecha (bit 2) de pos2
            elif y1 == y2:  # Pared vertical
                if x1 < x2:  # pos1 está arriba de pos2
                    self.walls[x1, y1] &= ~2  # Elimina la pared abajo (bit 1) de pos1
                    self.walls[x2, y2] &= ~8  # Elimina la pared arriba (bit 3) de pos2
                else:  # pos1 está abajo de pos2
                    self.walls[x1, y1] &= ~8  # Elimina la pared arriba (bit 3) de pos1
                    self.walls[x2, y2] &= ~2  # Elimina la pared abajo (bit 1) de pos2

    def update_door_matrix(self, door_position, state):
        """
        Actualiza la matriz de puertas del modelo para reflejar el estado actual.
        """
        (pos1, pos2) = door_position
        x1, y1 = pos1
        x2, y2 = pos2

        if state == "removed":
            # Determinar la dirección de la puerta a eliminar
            if x1 == x2:  # Puerta horizontal
                if y1 < y2:  # pos1 está a la izquierda de pos2
                    self.doors[x1, y1] &= ~4  # Elimina el bit derecho (bit 2) de pos1
                    self.doors[x2, y2] &= ~1  # Elimina el bit izquierdo (bit 0) de pos2
                else:  # pos1 está a la derecha de pos2
                    self.doors[x1, y1] &= ~1  # Elimina el bit izquierdo (bit 0) de pos1
                    self.doors[x2, y2] &= ~4  # Elimina el bit derecho (bit 2) de pos2
            elif y1 == y2:  # Puerta vertical
                if x1 < x2:  # pos1 está arriba de pos2
                    self.doors[x1, y1] &= ~2  # Elimina el bit abajo (bit 1) de pos1
                    self.doors[x2, y2] &= ~8  # Elimina el bit arriba (bit 3) de pos2
                else:  # pos1 está abajo de pos2
                    self.doors[x1, y1] &= ~8  # Elimina el bit arriba (bit 3) de pos1
                    self.doors[x2, y2] &= ~2  # Elimina el bit abajo (bit 1) de pos2

    def advance_goo(self):
        """Avanza la cantidad de los marcadores de riesgo."""

        # Verificar si quedan threat markers disponibles
        if not self.can_place_threat_marker():
            return

        # Obtener una lista de todas las posiciones en threat_markers
        threat_markers_positions = [(x, y) for x in range(self.height) for y in range(self.width)]

        # Elegir una posición aleatoria
        target_position = self.random.choice(threat_markers_positions)
        x, y = target_position

        # Verificar si la celda es el lootbug nest (0, 0)
        if (x, y) == (0, 0):
            return

        # Verificar si la celda está vacía
        if self.threat_markers[x, y] == 0:

            # Obtener las celdas adyacentes (vecindad de Moore)
            neighbors = self.grid.get_neighborhood((x, y), moore=True, include_center=False)

            # Verificar si no hay goo en las celdas adyacentes
            no_goo_nearby = all(
                self.threat_markers[nx, ny] != 2 for nx, ny in neighbors if 0 <= nx < self.height and 0 <= ny < self.width
            )

            if no_goo_nearby:
                # Colocar droplet en la celda seleccionada
                self.threat_markers[x, y] = 1
                self.current_threat_markers += 1
            elif not no_goo_nearby:
                # Colocar goo en la celda seleccionada
                self.threat_markers[x, y] = 2
                self.current_threat_markers += 1

        # Si la celda ya contiene un droplet
        elif self.threat_markers[x, y] == 1:
            self.threat_markers[x, y] = 2  # Colocar goo

        # Si la celda ya contiene goo
        elif self.threat_markers[x, y] == 2:
            self.explosion(x, y)

    def explosion(self, x, y):
        """Genera explosión de goo, afectando celdas adyacentes."""

        # Verificar si quedan threat markers disponibles
        if not self.can_place_threat_marker():
            return

        # Obtener las celdas adyacentes (vecindad de Von Neumann)
        neighbors = self.grid.get_neighborhood((x, y), moore=False, include_center=False)

        for nx, ny in neighbors:
            # Verificar si la celda está dentro de los límites
            if 0 <= nx < self.height and 0 <= ny < self.width:

                # Verificar si es el lootbug nest
                if (nx, ny) == (0, 0):
                    continue

                # Eliminar puertas entre la celda actual y la vecina
                door = tuple(sorted([(x, y), (nx, ny)]))
                if door in self.door_states:
                    if self.door_states[door] == "closed":
                        self.door_states[door] = "removed"
                        self.update_door_matrix(door, "removed")
                        continue # Detener la propagación en esta dirección
                    elif self.door_states[door] == "open":
                        self.door_states[door] = "removed"
                        self.update_door_matrix(door, "removed")

                # Identificar y dañar paredes entre la celda actual y la vecina
                wall = tuple(sorted([(x, y), (nx, ny)]))
                if wall in self.wall_states:
                    current_state = self.wall_states[wall]
                    if current_state == "okay":
                        self.wall_states[wall] = "damaged"
                        self.damage_counter -= 1
                        continue
                    elif current_state == "damaged":
                        self.wall_states[wall] = "destroyed"
                        self.damage_counter -= 1

                        # Actualizar la matriz de paredes para reflejar el estado destruido
                        self.update_wall_matrix(wall, "destroyed")
                        continue  # Detener la propagación en esta dirección


                # Si la celda contiene goo, comenzar shockwave.
                if self.threat_markers[nx, ny] == 2:
                    dx, dy = nx - x, ny - y  # Calcular la dirección
                    self.shockwave(nx, ny, direction=(dx, dy))
                    continue

                # Si la celda contiene un droplet, eliminarlo.
                if self.threat_markers[nx, ny] == 1:
                    self.threat_markers[nx, ny] = 0
                    self.current_threat_markers -= 1

                # Si la celda está vacía o contenía un droplet, colocar goo.
                if self.threat_markers[nx, ny] == 0:
                    self.threat_markers[nx, ny] = 2
                    self.current_threat_markers += 1

    def shockwave(self, x, y, direction):
        """Propaga una onda expansiva desde la celda especificada."""

        # Verificar si quedan threat markers disponibles
        if not self.can_place_threat_marker():
            return

        dx, dy = direction
        current_x, current_y = x, y
        while True:
            # Avanzar en la dirección especificada
            current_x += dx
            current_y += dy

            # Verificar si está fuera de los límites del grid
            if not (0 <= current_x < self.height and 0 <= current_y < self.width):
                break

            # Verificar si es el lootbug nest
            if (current_x, current_y) == (0, 0):
                break

            # Verificar si hay una puerta
            door = tuple(sorted([((current_x - dx), (current_y - dy)), (current_x, current_y)]))
            if door in self.door_states:
                if self.door_states[door] == "closed":
                    self.door_states[door] = "removed"
                    self.update_door_matrix(door, "removed")
                    break
                elif self.door_states[door] == "open":
                    self.door_states[door] = "removed"
                    self.update_door_matrix(door, "removed")

            # Verificar si hay una pared y/o puerta
            wall = tuple(sorted([((current_x - dx), (current_y - dy)), (current_x, current_y)]))
            if wall in self.wall_states:
                current_state = self.wall_states[wall]
                if current_state == "okay":
                    self.wall_states[wall] = "damaged"
                    self.damage_counter -= 1
                    break  # Detener la propagación en esta dirección
                elif current_state == "damaged":
                    self.wall_states[wall] = "destroyed"
                    self.damage_counter -= 1
                    self.update_wall_matrix(wall, "destroyed")
                    break  # La onda no puede pasar paredes destruidas

            # Verificar si es una celda con droplets
            if self.threat_markers[current_x, current_y] == 1:
                self.threat_markers[current_x, current_y] = 2
                break

            # Si la celda está vacía, colocar goo
            if self.threat_markers[current_x, current_y] == 0:
                self.threat_markers[current_x, current_y] = 2
                self.current_threat_markers += 1
                break

    def check_secondary_effects(self):
        """Revisar los efectos secundarios después del avance de goo."""

        # Iterar por todas las celdas de la cuadrícula
        for x in range(self.height):
            for y in range(self.width):
                # Verificar si la celda contiene un droplet
                if self.threat_markers[x, y] == 1:
                    # Obtener las celdas adyacentes (vecindad de Moore)
                    neighbors = self.grid.get_neighborhood((x, y), moore=True, include_center=False)

                    # Verificar si alguna celda adyacente contiene goo
                    goo_nearby = any(
                        self.threat_markers[nx, ny] == 2
                        for nx, ny in neighbors
                        if 0 <= nx < self.height and 0 <= ny < self.width
                    )

                    if goo_nearby:
                        # Cambiar el droplet por goo
                        self.threat_markers[x, y] = 0
                        self.threat_markers[x, y] = 2

    def end_game(self):
        """Verifica las condiciones de victoria o derrota y detiene la simulación si es necesario."""

        # Evitar múltiples llamadas si el juego ya terminó
        if not self.running:
            return

        if self.damage_counter == 0:
            self.collapsed_building = True

        if self.saved_victims == 7:
            self.running = False

        elif self.damage_counter == 0 or self.lost_victims == 4:
            self.running = False

    def step(self):
        """
        Ejecuta un paso en la simulación si esta está en ejecución.
        - Incrementa el contador de pasos.
        - Recolecta datos del estado actual de la simulación.
        - Avanza el estado de los agentes programados en el modelo.
        """
        if self.running:
            self.steps += 1
            self.schedule.step()
            self.datacollector.collect(self)

# Crear el json
import json
def convert_keys_to_str(data):
    """
    Convierte las claves de un diccionario a cadenas.
    """
    if isinstance(data, dict):
        return {str(key): convert_keys_to_str(value) for key, value in data.items()}
    elif isinstance(data, list):
        return [convert_keys_to_str(element) for element in data]
    else:
        return data

def run_model_and_save_to_json(steps: int, model_instance, output_file: str):
    """
    Ejecuta el modelo y guarda los datos recolectados en un archivo JSON.

    Args:
        steps (int): Número de pasos para ejecutar el modelo.
        model_instance: Instancia del modelo.
        output_file (str): Nombre del archivo donde se guardará el JSON.
    """
    # Ejecutar el modelo por el número de pasos especificado
    for step in range(steps):
        model_instance.step()  # Avanzar un paso en la simulación

    # Obtener los datos recolectados del DataCollector
    collected_data = model_instance.datacollector.get_model_vars_dataframe()

    # Formatear los datos en una estructura adecuada para JSON
    json_data = {
        "simulation_data": [],
        "summary": {
            "steps": steps,
            "collapsed_building": model_instance.collapsed_building,
            "saved_victims": model_instance.saved_victims,
            "lost_victims": model_instance.lost_victims,
        }
    }

    for index, row in collected_data.iterrows():
        json_data["simulation_data"].append({
            "step": row["Steps"],
            "grid_doors_entries": np.array(row["Grid 1 Puertas y salidas"]).tolist(),
            "grid_walls": np.array(row["Grid 2 Paredes"]).tolist(),
            "grid_poi": np.array(row["Grid 3 POI"]).tolist(),
            "grid_threat_markers": np.array(row["Grid 4 Threatmarkers"]).tolist(),
            "grid_agents": np.array(row["Grid 5 Agents"]).tolist(),
            "wall_states": convert_keys_to_str(row["Estados Paredes"]),  # Convertir claves a cadenas
            "door_states": convert_keys_to_str(row["Estados Puertas"]),  # Convertir claves a cadenas
            "collapsed_building": row["Edificio colapsado"],
            "saved_victims": row["Victimas salvadas"],
            "lost_victims": row["Victimas perdidas"],
        })


    # Guardar los datos como un archivo JSON
    with open(output_file, 'w') as outfile:
        json.dump(json_data, outfile, indent=4)
    print(f"Datos de simulación guardados en {output_file}.")





# -----------------------------------------------------------------------------------------------------------
# INICIALIZAR
# -----------------------------------------------------------------------------------------------------------

# Leer el archivo testCase.txt
with open("../testCase/testCase.txt") as file:
    lines = file.readlines()

# Procesar las líneas según la cantidad fija de líneas por sección
# Sección 1: matrix_walls (6 líneas)
matrix_walls = [line.split() for line in lines[:6]]

# Sección 2: matrix_poi (3 líneas)
def process_poi_row(row):
    return [int(item) if item.isdigit() else item for item in row.split()]

matrix_poi = [process_poi_row(line) for line in lines[6:9]]

# Sección 3: matrix_goo (10 líneas)
matrix_goo = [list(map(int, line.split())) for line in lines[9:19]]

# Sección 4: matrix_doors (8 líneas)
matrix_doors = [list(map(int, line.split())) for line in lines[19:27]]

# Sección 5: matrix_entry_points (4 líneas)
matrix_entry_points = [list(map(int, line.split())) for line in lines[27:31]]

# Crear una instancia del modelo
model = ModeloEdificio(matrix_walls, matrix_poi, matrix_goo, matrix_doors, matrix_entry_points)



# Ejemplo de uso
if __name__ == "__main__":
    # Crear una instancia del modelo con datos iniciales
    wall_data = matrix_walls  # Datos de paredes
    poi_data = matrix_poi  # Datos de puntos de interés
    goo_data = matrix_goo  # Datos de goo
    doors_data = matrix_doors  # Datos de puertas
    entry_points_data = matrix_entry_points  # Puntos de entrada

    # Instanciar el modelo
    modelo = ModeloEdificio(wall_data, poi_data, goo_data, doors_data, entry_points_data)

    # Ejecutar el modelo y guardar los datos
    run_model_and_save_to_json(steps=100, model_instance=modelo, output_file="simulation_output.json")



unityFriendlyWalls = []
unityFriendlyPoi = []
unityFriendlyGoo = []
unityFriendlyDoors = []
unityFriendlyAgents = []

matrixWallsInDecimal = get_grid_walls(model)
matrixPoiInDecimal = get_grid_poi(model)
matrixGooInDecimal = get_grid_threat_markers(model)
matrixDoorsInDecimal = get_grid_doors_entries(model)
matrixAgentsInDecimal = get_grid(model)

for x in range(len(matrixWallsInDecimal)):  # Recorrer las filas
    for y in range(len(matrixWallsInDecimal[0])):  # Recorrer las columnas
        wall_value = int(matrixWallsInDecimal[x][y])  # Extraer el valor entero de la pared
        unityFriendlyWalls.append({"x": x, "y": y, "WallValue": wall_value})


for x in range(len(matrixPoiInDecimal)):  # Recorrer las filas
    for y in range(len(matrixPoiInDecimal[0])):  # Recorrer las columnas
        poi_value = int(matrixPoiInDecimal[x][y])  # Extraer el valor entero del POI
        unityFriendlyPoi.append({"x": x, "y": y, "PoiValue": poi_value})

for x in range(len(matrixGooInDecimal)):  # Recorrer las filas
    for y in range(len(matrixGooInDecimal[0])):  # Recorrer las columnas
        goo_value = int(matrixGooInDecimal[x][y])  # Extraer el valor entero del goo
        unityFriendlyGoo.append({"x": x, "y": y, "GooValue": goo_value})

for x in range(len(matrixDoorsInDecimal)):
    for y in range(len(matrixDoorsInDecimal[0])):
        door_value = int(matrixDoorsInDecimal[x][y])
        unityFriendlyDoors.append({"x": x, "y":y, "DoorValue": door_value})

for x in range(len(matrixAgentsInDecimal)):
    for y in range(len(matrixAgentsInDecimal[0])):
        agent_value = int(matrixAgentsInDecimal[x][y])
        unityFriendlyAgents.append({"x": x, "y": y, "AgentValue": agent_value})


# Construir el diccionario de datos
data = {
    "Walls": unityFriendlyWalls,
    "POIs": unityFriendlyPoi,
    "Goo": unityFriendlyGoo,
    "Doors": unityFriendlyDoors,
    "Agents": unityFriendlyAgents,
}


# Convertir el diccionario a JSON
json_data = json.dumps(data)

def get_matrixes():
    return json_data

def step_in_simulation():
    model.step()  # Avanza un paso en la simulación
    return get_matrixes()  # Devuelve el estado actualizado en formato JSON

