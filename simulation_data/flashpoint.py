# -*- coding: utf-8 -*-
"""FlashPoint_V2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1eRMVu3LGsCdgXBEDDPT7qwMTLSxZgqt2

# Mesa + Libraries
"""

#!pip install mesa==2.3.1 --quiet

# Importamos las clases que se requieren para manejar los agentes (Agent) y su entorno (Model).
from mesa import Agent, Model

# Usamos ''MultiGrid'' para representar una cuadrícula donde cada celda puede contener como máximo un agente.
from mesa.space import MultiGrid

# ''DataCollector'' nos permite recolectar y almacenar datos en cada paso de la simulación para su análisis posterior.
from mesa.datacollection import DataCollector

# Con ''RandomActivation'', activamos a todos los agentes en cada paso.
from mesa.time import RandomActivation

# Importamos cityblock para calcular la distancia Manhattan entre dos puntos.
from scipy.spatial.distance import cityblock

# Usamos matplotlib para generar animaciones y visualizar el progreso de la simulación en cada paso.
# %matplotlib inline
import matplotlib
import matplotlib.pyplot as plt
import matplotlib.animation as animation
from matplotlib.colors import ListedColormap
plt.rcParams["animation.html"] = "jshtml"
matplotlib.rcParams['animation.embed_limit'] = 2**128

# Importamos los siguientes paquetes para el mejor manejo de valores numéricos.
import numpy as np
import pandas as pd
import random

# ''seaborn'' nos permite crear gráficos estadísticos.
# import seaborn as sns

# Importamos paquetes adicionales para medir el tiempo de ejecución del algoritmo.
import time
import datetime

"""#EmployeeAgent"""

class EmployeeAgent(Agent):
    """Clase que representa a un empleado que salva víctimas en el edificio de Lethal Company."""

    def __init__(self, id, model):
        """
        Inicializa las propiedades del agente.
        - id: Identificador único del agente.
        - model: Referencia al modelo al que pertenece el agente.
        """
        super().__init__(id, model)
        self.ap = 4  # Puntos de acción disponibles
        self.carrying_victim = False  # Estado de transporte de víctima
        self.finished_turn = False  # Estado del turno del agente
        self.next_cell = None  # Próxima celda a la que se moverá el agente
        self.remaining_AP = 0 # Puntos de acción restantes

    def step(self):
        """
        Define el comportamiento del agente en cada paso del modelo.
        Solo actúa si es su turno y evalúa si debe realizar una acción o finalizar su turno.
        """

        # Verifica si es el turno del agente.
        if self.model.turn == self.unique_id:
            print(f"{self.unique_id}: AP -> {self.ap}")
            self.finished_turn = False

            # Reinicia el objetivo al inicio del turno.
            self.goal = None

            # Realiza una acción si tiene puntos de acción disponibles y no ha terminado su turno.
            if self.ap >= 1 and not self.finished_turn:
                self.perform_single_action()

            # Finaliza el turno si no tiene puntos de acción o ha cumplido su objetivo.
            if self.ap == 0 or self.finished_turn:
                self.end_turn()

    def perform_single_action(self):

        """
        Realiza una acción simple, como extinguir goo o buscar un objetivo.
        """

        # Verifica si alcanzó su objetivo antes de realizar una acción.
        self.check_reached_goal()

        if not self.finished_turn:
            # Si hay goo o droplets en la celda actual, lo extingue.
            if self.model.threat_markers[self.pos] in [1, 2]:
                self.extinguish()

            else:
                # Busca goo/droplets en las celdas vecinas.
                neighbor_positions = self.model.grid.get_neighborhood(self.pos, moore=False, include_center=False)

                # Indica si el agente extinguió algo.
                self.extinguished = False

                # Indica que el agente se movió aleatoriamente
                self.moved = False

                # Busca vecinos válidos.
                valid_neighbors = self.looking_for_valid_neighbours()

                for valid_neighbor_pos in valid_neighbors:
                    x, y = valid_neighbor_pos
                    # Si encuentra goo o droplets en la celda vecina, lo extingue.
                    if self.model.threat_markers[(x, y)] in [1, 2]:
                        self.extinguish((x, y))
                        self.extinguished = True
                        break

                # Si no extinguió nada, define un objetivo y se dirige a él.
                if not self.extinguished:

                    # Si lleva una víctima, busca la salida más cercana; de lo contrario, busca una víctima.
                    self.goal = 16 if self.carrying_victim else 1
                    goal_position = self.search_goal_position(self.goal)

                    if goal_position:
                        self.go_to_goal_position(goal_position)
                        self.check_reached_goal()
                    else:
                        self.move_random()
                    self.moved = True

                # Finalizar el turno si no hay más acciones posibles
                if self.ap <= 0 or self.finished_turn == True or (not self.extinguished and not self.moved):
                    self.finished_turn = True

    def move_random(self):
        # Busca vecinos válidos.
        valid_neighbors = self.looking_for_valid_neighbours()

        # Escoge un vecino válido aleatorio que no sea (0,0).
        valid_neighbors = [pos for pos in valid_neighbors if pos != (0, 0)]

        if valid_neighbors:
            # Selecciona un vecino aleatorio.
            target_position = random.choice(valid_neighbors)
            print(f"Agente {self.unique_id}: Se moverá random a {target_position}")

            self.move_agent_to(target_position)  # Mueve al agente a la posición seleccionada.

        else:
            # Si no encuentra vecinos válidos, termina su turno.
            print(f"Agente {self.unique_id}: No encontró vecinos válidos.")
            self.finished_turn = True

    def looking_for_valid_neighbours(self):
        """
        Busca vecinos válidos donde no haya paredes o puertas que impidan adyacencias.
        """
        # Lista para almacenar los vecinos válidos.
        valid_neighbors = []

        # Obtiene las posiciones vecinas.
        neighbor_positions = self.model.grid.get_neighborhood(self.pos, moore=False, include_center=False)

        for neighbor_pos in neighbor_positions:
            x, y = neighbor_pos

            # Verificar si hay una puerta cerrada entre la celda actual y la vecina.
            current_pos = self.pos
            door = tuple(sorted([current_pos, neighbor_pos]))
            if door in self.model.door_states and self.model.door_states[door] == "closed":
                continue  # Puerta cerrada, no es vecino válido.

            # Verifica si hay una pared entre la celda actual y la vecina.
            wall = tuple(sorted([current_pos, neighbor_pos]))
            if wall in self.model.wall_states:
                wall_state = self.model.wall_states[wall]
                if wall_state in ["okay", "damaged"]:
                    continue  # Hay una pared, no es vecino válido.

            # Si pasa las verificaciones, es un vecino válido.
            valid_neighbors.append(neighbor_pos)

        return valid_neighbors

    def end_turn(self):
        """
        Finaliza el turno del agente, restablece puntos de acción y pasa al siguiente agente.
        """
        # Verifica si el juego debe terminar. Si el juego ha terminado, no continúa.
        self.model.end_game()
        if not self.model.running:
          return

        print(f"Agente {self.unique_id}: Turno finalizado. AP restantes: {self.ap}")

        # Avanza la cantidad de marcadores de riesgo.
        self.model.advance_goo()

        # Revisar efectos secundarios.
        self.model.check_secondary_effects()
        self.knocked_down()

        # Reabastece puntos de interés si es necesario.
        self.model.replenish_pois()

        # Restablece los puntos de acción para el siguiente turno.
        self.remaining_AP = self.ap
        self.remaining_AP = min(self.ap, 4)  # Limitar a 4 AP extras máximo

        self.ap = 4 + self.remaining_AP
        print(f"Agente {self.unique_id}: Empezara siguiente turno con: {self.ap}")

        self.remaining_AP = 0
        self.finished_turn = False

        # Verifica si el juego debe terminar. Si el juego ha terminado, no continúa.
        self.model.end_game()
        if not self.model.running:
          return

        # Pasa el turno al siguiente agente.
        self.model.turn += 1
        print(f"\nSiguiente turno: Agente {self.model.turn}")

    def extinguish(self, position=None):
        """
        Extingue goo o droplets en una celda específica.
        """
        if position is None:
            position = self.pos

        # Si es goo, cambia de goo a droplet.
        if self.model.threat_markers[position] == 2:
            self.model.threat_markers[position] = 1
            self.ap -= 1
            print(f"Agente {self.unique_id}: Extinguió goo en {position}. AP restantes: {self.ap}")

        # Si es droplet, cambia a vacío.
        elif self.model.threat_markers[position] == 1:
            self.model.threat_markers[position] = 0
            self.model.current_threat_markers -= 1  # Actualizar el contador
            self.ap -= 1
            print(f"Agente {self.unique_id}: Extinguió droplet en {position}. AP restantes: {self.ap}")

        self.check_if_turn_finished()

    def check_reached_goal(self):
        """
        Verifica si el agente ha alcanzado su objetivo:
        - Salvar a una víctima.
        - Detectar un punto de interés (POI).
        """
        if self.carrying_victim and self.model.entry_points_location[self.pos] == 16:
            # Si lleva una víctima y llega a la salida.
            self.model.saved_victims += 1
            self.model.poi_real_victim -= 1
            self.model.poi_total_count -= 1
            self.model.poi_in_building -= 1

            print(f"Agente {self.unique_id}: Víctima salvada. Total: {self.model.saved_victims}")
            self.carrying_victim = False
            self.finished_turn = True
        elif not self.carrying_victim and self.model.poi_placement[self.pos] in [3, 4]:
            # Si encuentra un POI válido.
            print(f"Agente {self.unique_id}: POI encontrado.")
            self.reveal_poi()

    def reveal_poi(self):
        """
        Revela el Punto de Interés (POI) en la celda actual del agente.
        Si el POI es una falsa alarma, se elimina y se actualizan los contadores correspondientes.
        Si el POI representa a una víctima, el agente la recoge.
        """
        if self.model.poi_placement[self.pos] == 3:  # Si el POI es una falsa alarma.
            self.model.poi_placement[self.pos] = 0  # Elimina el POI de la celda.
            self.model.poi_false_alarm -= 1 # Reduce el contador de falsas alarmas.
            self.model.poi_total_count -= 1 # Reduce el total de POIs.
            self.model.poi_in_building -= 1 # Reduce el total de POIs dentro del edificio.
            print(f"Agente {self.unique_id}: POI era falsa alarma.")
        elif self.model.poi_placement[self.pos] == 4 and not self.carrying_victim:
            # Si el POI representa a una víctima y el agente no está transportando una.
            self.carrying_victim = True # El agente recoge a la víctima.
            self.model.poi_placement[self.pos] = 0
            print(f"Agente {self.unique_id}: Encontré una víctima.")

    def search_goal_position(self, goal):
        """
        Busca la posición más cercana al objetivo indicado:
        - goal = 1: Busca un POI (valores 3 o 4) más cercano.
        - goal = 16: Busca la salida más cercana.
        - si no hay posición objetivo válida, se mueve aleatoriamente para apaagr fuego.**
        Retorna la posición objetivo más cercana.
        """

        # Buscar POIs más cercanos (víctimas o falsas alarmas).
        if self.goal == 1:
            min_distance = float("inf")
            nearest_position = None
            for x in range(self.model.grid.width):
                for y in range(self.model.grid.height):
                    if self.model.poi_placement[(x, y)] in [3, 4]:
                        # Calcula distancia Manhattan.
                        distance = cityblock(self.pos, (x, y))
                        if distance < min_distance:
                            min_distance = distance
                            nearest_position = (x, y)

        # Buscar la salida más cercana
        if self.goal == 16:
            min_distance = float("inf")
            nearest_position = None
            for x in range(self.model.grid.width):
                for y in range(self.model.grid.height):
                    if self.model.entry_points_location[(x, y)] == goal:
                        # Calcula distancia Manhattan.
                        distance = cityblock(self.pos, (x, y))
                        if distance < min_distance:
                            min_distance = distance
                            nearest_position = (x, y)
        return nearest_position

    def go_to_goal_position(self, goal_position):
        """
        Mueve al agente hacia la posición objetivo especificada.
        Considera paredes y puertas como posibles obstáculos.
        """
        goal_x, goal_y = goal_position
        current_x, current_y = self.pos

        # Determina la dirección del movimiento hacia el objetivo.
        if current_x < goal_x:
            new_pos = (current_x + 1, current_y)
        elif current_x > goal_x:
            new_pos = (current_x - 1, current_y)
        elif current_y < goal_y:
            new_pos = (current_x, current_y + 1)
        elif current_y > goal_y:
            new_pos = (current_x, current_y - 1)
        else:
            # Si ya está en la posición objetivo, marca el turno como finalizado.
            self.finished_turn = True
            return

        # Intenta moverse hacia la nueva posición verificando obstáculos.
        self.move_to_new_position(new_pos)

    def move_to_new_position(self, new_position):
        """
        Intenta mover al agente a la nueva posición indicada.
        Considera si hay puertas o paredes entre la celda actual y la nueva posición.
        """
        current_x, current_y = self.pos
        new_x, new_y = new_position

        # Verificar si hay una puerta entre la posición actual y la nueva posición.
        door = tuple(sorted([(current_x, current_y), (new_x, new_y)]))
        has_door = door in self.model.door_states

        if has_door:
            door_state = self.model.door_states[door]
            if door_state == "closed":
                # Si la puerta está cerrada, intenta abrirla.
                if self.ap >= 1:
                    self.open_door(door)
                else:
                    print(f"Agente {self.unique_id}: No tiene AP para abrir la puerta entre {door}.")
                    self.finished_turn = True
            elif door_state == "open" or door_state == "removed":
                # Si la puerta está abierta, se mueve a través de ella.
                self.move_agent_to(new_position)
        else:
            # Verifica si hay una pared entre la celda actual y la nueva posición.
            wall = tuple(sorted([(current_x, current_y), (new_x, new_y)]))
            has_wall = wall in self.model.wall_states

            if has_wall:
                wall_state = self.model.wall_states[wall]
                if wall_state == "destroyed":
                    # Si la pared está destruida, se mueve a través de ella.
                    self.move_agent_to(new_position)
                else:
                    # Si la pared está intacta o dañada, intenta dañarla si es posible.
                    if self.model.damage_counter <= 6:
                        # Mover aleatoriamente
                        self.move_random()
                        print(f"Agente {self.unique_id}: No puede dañar más paredes o derrumbará el edificio.")
                        return
                    elif self.ap >= 2:
                        self.damage_wall(wall)
                    else:
                        print(f"Agente {self.unique_id}: No tiene AP para dañar la pared entre {wall}.")
                        self.finished_turn = True
            else:
                # Si no hay paredes ni puertas, se mueve directamente.
                self.move_agent_to(new_position)

    def open_door(self, door):
        """
        Abre una puerta cerrada entre dos celdas.
        - Actualiza el estado de la puerta a "open".
        - Reduce los puntos de acción (AP) del agente en 1.
        """
        self.model.door_states[door] = "open"
        self.ap -= 1
        print(f"Agente {self.unique_id}: Abrió la puerta entre {door}. AP restantes: {self.ap}")

    def damage_wall(self, wall_position):
        """
        Daña o destruye una pared en la posición especificada.
        - Si la pared está en estado "okay", la daña.
        - Si la pared ya está dañada, la destruye.
        - Actualiza los contadores y el estado de las paredes.
        """

        # Obtener el estado actual de la pared
        wall_state = self.model.wall_states[wall_position]

        if wall_state == "okay":
            # Si la pared está intacta, se daña.
            self.model.wall_states[wall_position] = "damaged"
            self.ap -= 2
            self.model.damage_counter -= 1
            print(f"Agente {self.unique_id}: Dañó la pared en {wall_position}. AP restantes: {self.ap}")

        elif wall_state == "damaged":
            # Si la pared ya está dañada, se destruye.
            self.model.wall_states[wall_position] = "destroyed"
            self.ap -= 2
            self.model.damage_counter -= 1
            print(f"Agente {self.unique_id}: Destruyó la pared en {wall_position}. AP restantes: {self.ap}")

            # Determinar qué pared fue destruida.
            (pos1, pos2) = wall_position
            x1, y1 = pos1
            x2, y2 = pos2

            # Pared horizontal
            if x1 == x2:
                if y1 < y2:
                    if self.model.walls[x1, y1] & 4:
                        print(f"Agente {self.unique_id}: Destruyó la pared derecha de {pos1} y la pared izquierda de {pos2}.")
                else:
                    if self.model.walls[x1, y1] & 1:
                        print(f"Agente {self.unique_id}: Destruyó la pared izquierda de {pos1} y la pared derecha de {pos2}.")

            # Pared vertical
            elif y1 == y2:
                if x1 < x2:
                    if self.model.walls[x1, y1] & 2:
                        print(f"Agente {self.unique_id}: Destruyó la pared abajo de {pos1} y la pared arriba de {pos2}.")
                else:
                    if self.model.walls[x1, y1] & 8:
                        print(f"Agente {self.unique_id}: Destruyó la pared arriba de {pos1} y la pared abajo de {pos2}.")

            # Actualiza la matriz de paredes para reflejar el estado destruido.
            self.model.update_wall_matrix(wall_position, "destroyed")

        else:
            # Si la pared ya está destruida, no realiza ninguna acción.
            print(f"Agente {self.unique_id}: La pared en {wall_position} ya está destruida.")

    def move_agent_to(self, new_position):
        """
        Mueve al agente a una nueva posición dentro de la cuadrícula.
        - Si la nueva posición es inválida, bloquea el movimiento.
        - Reduce los puntos de acción (AP) según el estado del agente.
        """

        # Evita que el agente se mueva a la posición (0, 0).
        if new_position == (0, 0):
            print(f"Agente {self.unique_id}: Intento de moverse a (0, 0) bloqueado.")
            self.finished_turn = True
            return

        # Verifica si la nueva posición está dentro de los límites de la cuadrícula.
        if (0 <= new_position[0] < self.model.grid.width and
            0 <= new_position[1] < self.model.grid.height):
            # Mueve al agente a la nueva posición.
            self.model.grid.move_agent(self, new_position)

            # Reduce los puntos de acción (AP) según el estado del agente.
            if not self.carrying_victim:
                self.ap -= 1
            elif self.carrying_victim and self.ap >=2:
                self.ap -= 2
            else:
                # Finaliza el turno si no hay suficientes AP
                self.finished_turn = True
            print(f"Agente {self.unique_id}: Movido a {new_position}. AP restantes: {self.ap}")
        else:
            # Si la nueva posición está fuera de los límites, bloquea el movimiento.
            print(f"Agente {self.unique_id}: Movimiento inválido a {new_position}.")
            self.finished_turn = True

    def knocked_down(self):
        """Revisar si algún empleado o víctima resultó herido al estar en una celda con goo."""
        print("Revisando empleados en celdas con goo...")

        # Iterar sobre los agentes en el modelo
        for agent in self.model.schedule.agents:
            # Verificar si el agente es un EmployeeAgent
            if isinstance(agent, EmployeeAgent):
                x, y = agent.pos  # Obtener la posición del empleado
                # Verificar si la celda contiene goo
                if self.model.threat_markers[x, y] == 2:
                    # Manejar el efecto de goo sobre el empleado
                    print(f"Empleado {agent.unique_id} está en una celda con goo en ({x}, {y}). Marcado como herido.")

                     # Si el agente lleva una víctima, se pierde
                    if agent.carrying_victim:
                        print(f"Empleado {agent.unique_id} llevaba una víctima que se pierde.")
                        self.model.poi_total_count -= 1
                        self.model.poi_real_victim -= 1
                        agent.carrying_victim = False
                        self.model.lost_victims += 1
                        print(f"Víctima perdida. Víctimas reales restantes: {self.model.poi_real_victim}, Total POIs: {self.model.poi_total_count}")

                    # Terminar el turno del agente
                    agent.finished_turn = True

                    # Eliminar al agente del grid
                    self.model.grid.remove_agent(agent)

                    # Elegir un punto de entrada aleatorio
                    random_entry_point = self.random.choice(self.model.entry_points)

                    # Colocar al agente en el punto de entrada
                    self.model.grid.place_agent(agent, random_entry_point)
                    agent.pos = random_entry_point  # Actualizar posición del agente
                    print(f"Empleado {agent.unique_id} fue trasladado al punto de entrada {random_entry_point}.")

        # Revisar si hay POIs en celdas con goo
        for x in range(self.model.height):
            for y in range(self.model.width):
                # Si la celda contiene goo y un POI
                if self.model.threat_markers[x, y] == 2 and self.model.poi_placement[x, y] in [3, 4]:
                    poi_type = self.model.poi_placement[x, y]
                    self.model.poi_placement[x, y] = 0  # Eliminar el POI del grid
                    self.model.poi_total_count -= 1
                    self.model.poi_in_building -= 1

                    if poi_type == 4:  # Si era una víctima
                        self.model.poi_real_victim -= 1
                        self.model.lost_victims += 1
                        print(f"Víctima en ({x}, {y}) fue perdida. Total de víctimas perdidas: {self.model.lost_victims}.")
                    elif poi_type == 3:  # Si era una falsa alarma
                        self.model.poi_false_alarm -= 1
                        print(f"Falsa alarma en ({x}, {y}) eliminada.")

        print("Revisión de efectos de goo completada.")

    def check_if_turn_finished(self):
        """
        Verifica si el turno del agente debe finalizar.
        - El turno termina si los puntos de acción (AP) se agotan o si ya se marcó como finalizado.
        """
        print(f"Agente {self.unique_id}: Checando turn finished.")

        if self.ap <= 0 or self.finished_turn:
            print(f"Agente {self.unique_id}: Se acabó mi energía y mi turno.")
            self.end_turn()

"""# LootBugAgent"""

class LootBugAgent(Agent):
    """Clase que representa a un Lootbug. Este se encarga de mover a los POIs para elevar el juego."""
    def __init__(self, id, model):
        super().__init__(id, model)
        """
        Inicializa las propiedades del agente LootBug.
        - id: Identificador único del agente.
        - model: Referencia al modelo.
        """
        self.cargando_poi = False  # Indica si el agente está cargando un POI.
        self.poi_cargado = None  # Almacena el tipo de POI que lleva cargado.
        self.state = "capturar_poi"  # Estado inicial del agente.

    def teleport(self, target):
        """Teletransportar al agente a una posición específica."""
        self.model.grid.move_agent(self, target)

    def step(self):
        """
        Define las acciones del LootBug en su turno, basado en su estado actual.
        Los estados incluyen capturar un POI, colocar el POI y regresar al origen.
        """
        if self.model.turn == self.unique_id:
            # Verificar si el juego ha terminado antes de proceder
            self.model.end_game()
            if not self.model.running:
                return

            print(f"\n[Turno LootBug {self.unique_id}] Estado actual: {self.state}")


            if self.state == "capturar_poi":
                """
                Estado para buscar y recoger un POI.
                - Encuentra un POI disponible en la cuadrícula.
                - Se teletransporta al POI y lo recoge.
                """
                poi_positions = [(x, y) for x in range(self.model.height) for y in range(self.model.width)
                                if self.model.poi_placement[x, y] in [3, 4]]

                # Si hay POIs disponibles.
                if poi_positions:
                    self.target_poi = self.random.choice(poi_positions)
                    print(f"LootBug {self.unique_id} encontró un POI en {self.target_poi}. Teletransportándose...")
                    self.teleport(self.target_poi)

                    # Recoger el POI.
                    x, y = self.pos
                    self.poi_cargado = self.model.poi_placement[x, y]
                    self.model.poi_placement[x, y] = 0
                    print(f"LootBug {self.unique_id} recogió el POI ({'Falsa Alarma' if self.poi_cargado == 3 else 'Víctima'}) en {self.target_poi}.")
                    self.state = "colocar_poi"
                else:
                    # Finaliza el turno si no hay POIs.
                    print("No hay POIs disponibles para que agarre el lootbug.")
                    self.end_turn()

            elif self.state == "colocar_poi":
                """
                Estado para colocar el POI en una celda vacía.
                - Busca una celda libre y se teletransporta a ella.
                - Coloca el POI en la nueva posición.
                """
                valid_cells = [(x, y) for x in range(self.model.height) for y in range(self.model.width)
                              if self.model.poi_placement[x, y] == 0  # Celda libre en el grid de POIs
                              and not self.model.grid.get_cell_list_contents((x, y))]  # Celda libre en el grid de agentes
                if valid_cells:
                    # Si hay celdas válidas.
                    new_position = self.random.choice(valid_cells) # Selecciona una celda aleatoria.
                    nx, ny = new_position

                    # Verifica si la celda seleccionada contiene marcadores de amenaza y los elimina.
                    if self.model.threat_markers[nx, ny] in [2, 1]:
                      print(f"Marcador de amenaza detectado en ({nx}, {ny}). Eliminando marcador...")
                      self.model.threat_markers[nx, ny] = 0
                      self.model.current_threat_markers -= 1  # Actualizar el contador

                    print(f"LootBug {self.unique_id} se teletransporta a {new_position} para colocar el POI.")
                    self.teleport(new_position)  # Se teletransporta a la celda seleccionada.
                    self.model.poi_placement[nx][ny] = self.poi_cargado # Deja el POI.
                    print(f"LootBug {self.unique_id} dejó el POI ({'Falsa Alarma' if self.poi_cargado == 3 else 'Víctima'}) en {new_position}.")
                    self.poi_cargado = None # Vacía su carga de POI.
                    self.state = "volver_origen" # Cambia al estado para regresar al origen.

            elif self.state == "volver_origen":
                """
                Estado para regresar al origen (0, 0).
                - Se teletransporta al origen.
                - Reinicia el ciclo volviendo al estado inicial.
                """
                print(f"LootBug {self.unique_id} regresa a su posición inicial (0, 0).")
                self.teleport(self.model.lootbug_nest)
                self.state = "capturar_poi"  # Reiniciar ciclo
                self.end_turn()

    def end_turn(self):
        """
        Finaliza el turno del LootBug.
        - Incrementa el turno del modelo.
        - Si supera el total de agentes, reinicia el contador de turnos.
        """
        print(f"LootBug {self.unique_id} finalizó su turno.")
        self.model.turn += 1
        if self.model.turn >= len(self.model.schedule.agents):
            # Reinicia el turno si sobrepasa el total
            self.model.turn = 0

"""# Grid 1 - Puertas y puntos de entrada"""

def get_grid_doors_entries(model):
    """Crea una representación de las puertas y puntos de entrada del edificio."""
    # Copiar la matriz base (puertas) para superponer información adicional
    combined_grid = np.copy(model.doors)

    # Superponer los puntos de entrada en la matriz combinada
    for x, y in model.entry_points:
        combined_grid[x, y] = max(combined_grid[x, y], 16)

    # Superponer el lootbug nest en la matriz combinada
    if hasattr(model, "lootbug_nest"):  # Verifica que el atributo lootbug_nest exista
        nest_x, nest_y = model.lootbug_nest
        combined_grid[nest_x, nest_y] = max(combined_grid[nest_x, nest_y], 32)  # Usamos 32 para lootbug nest



    return combined_grid

"""# Grid 2 - Paredes"""

def get_grid_walls(model):
    """Crea una representación de las paredes del edificio."""
    grid = model.walls.copy()

    return grid

"""#Grid 3 - POI"""

def get_grid_poi(model):
    """Crea una representación de los POI en el edificio."""
    grid = model.poi_placement.copy()

    return grid

"""#Grid 4 - Threatmarkers



"""

def get_grid_threat_markers(model):
    """Crea una representación de los threath markers en el edificio."""
    grid = model.threat_markers.copy()

    return grid

"""#Grid 5 - Agents"""

def get_grid(model):
    """Crea una representación de los agentes en el edificio."""
    grid = np.zeros((model.grid.width, model.grid.height))

    # Iterar sobre todas las celdas del grid
    for content, (x, y) in model.grid.coord_iter():
        for agent in content:
            if isinstance(agent, EmployeeAgent):
                grid[x][y] = 6  # Representar el agente con el valor 6
            if isinstance(agent, LootBugAgent):
                grid[x][y] = 7  # Representar el agente con el valor 7


    return grid

"""#Model"""

class ModeloEdificio(Model):
    """Modelo del edificio Lethal company."""
    def __init__(self, wall_data, poi_data, goo_data, doors_data, entry_points_data):
        super().__init__()

        # Agentes
        self.turn = 0
        self.employee_agents = 6
        self.lootbug_agents = 1
        self.schedule = RandomActivation(self)

        # Dimensiones del modelo
        self.height = 6
        self.width = 8

        # Grid del modelo
        self.grid = MultiGrid(self.height, self.width, torus=False)
        self.running = True
        self.steps = 0

        # Variables del modelo
        self.max_threat_markers = 32
        self.current_threat_markers = 0
        self.poi_total_count = 15
        self.poi_false_alarm = 5
        self.poi_real_victim  = 10
        self.poi_in_building = 0

        self.damage_counter = 24
        self.door_markers = 8
        self.start_point = 4
        self.saved_victims = 0
        self.lost_victims = 0
        self.collapsed_building = False
        self.lootbug_nest = (0,0)

        # Diccionario para rastrear estados de POIs ('closes' o 'open').
        self.poi_states = {}

        # Diccionario para rastrear estados de puertas.
        # Tuplas de posiciones adyacentes, y los valores son 'closed' o 'open'.
        self.door_states = {}

        # Diccionario para rastrear estados de paredes.
        # Clave: ((x1, y1), (x2, y2)), Valor: "okay", "damaged", "destroyed".
        self.wall_states = {}

        # Matrices para representar el estado del edificio.
        self.entry_points_location = np.zeros((self.height, self.width))

        # Paredes: cada celda contiene un entero donde cada bit representa una dirección:
        # Bit 0: Arriba, Bit 1: Derecha, Bit 2: Abajo, Bit 3: Izquierda
        self.walls = np.zeros((self.height, self.width), dtype=int)
        self.doors = np.zeros((self.height, self.width), dtype=int)

        # Matrices para objetos
        self.threat_markers = np.zeros((self.height, self.width)) # goo y droplets
        self.poi_placement = np.zeros((self.height, self.width)) # POIs

        # Colocar elementos iniciales
        self.place_walls(wall_data)    # Colocar paredes
        self.place_poi(poi_data)      # Colocar los POIs respetando el número por tipo
        self.place_goo(goo_data)      # Colocar el goo
        self.place_doors(doors_data)    # Colocar puertas
        self.place_start_point(entry_points_data)  # Colocar puntos de entradas

        # Crear y colocar agentes
        self.place_employees()
        self.place_lootbug()

        # Inicializar recolector de datos
        self.datacollector = DataCollector(
            model_reporters={
                "Grid 1 Puertas y salidas": get_grid_doors_entries,
                "Grid 2 Paredes": get_grid_walls,
                "Grid 3 POI": get_grid_poi,
                "Grid 4 Threatmarkers": get_grid_threat_markers,
                "Grid 5 Agents": get_grid,
                "Steps": lambda model: model.steps,
                "Edificio colapsado": lambda model: model.collapsed_building,
                "Victimas salvadas": lambda model: model.saved_victims,
                "Victimas perdidas": lambda model: model.lost_victims,
            }
        )

    def place_lootbug(self):
        """Coloca agentes en puntos de entrada seleccionados aleatoriamente."""
        for i in range(self.lootbug_agents):

            # Crear el agente
            agent = LootBugAgent(self.employee_agents, self)

            # Colocar el agente en el punto de entrada
            self.grid.place_agent(agent, self.lootbug_nest)

            # Agregar el agente al schedule
            self.schedule.add(agent)

    def place_employees(self):
        """Coloca agentes en puntos de entrada seleccionados aleatoriamente."""
        for i in range(self.employee_agents):
            # Seleccionar un punto de entrada aleatorio
            random_entry_point = self.random.choice(self.entry_points)

            # Crear el agente
            agent = EmployeeAgent(i, self)

            # Colocar el agente en el punto de entrada
            self.grid.place_agent(agent, random_entry_point)

            # Agregar el agente al schedule
            self.schedule.add(agent)

    def place_walls(self, wall_data):
        """Coloca paredes en posiciones específicas y asigna sus estados correctamente según la matriz dada."""
        for i in range(self.height):
            for j in range(self.width):
                wall_value = int(wall_data[i][j], 2)  # Convertir binario a entero
                self.walls[i, j] = wall_value  # Guardar el valor decimal de las paredes

                # Definir las paredes basadas en los bits (arriba, derecha, abajo, izquierda).
                if wall_value & 8:  # Pared arriba (bit 3)
                    if i > 0:
                        wall_pos = ((i, j), (i - 1, j))
                        self.wall_states[tuple(sorted(wall_pos))] = "okay"

                if wall_value & 4:  # Pared derecha (bit 2)
                    if j < self.width - 1:
                        wall_pos = ((i, j), (i, j + 1))
                        self.wall_states[tuple(sorted(wall_pos))] = "okay"

                if wall_value & 2:  # Pared abajo (bit 1)
                    if i < self.height - 1:
                        wall_pos = ((i, j), (i + 1, j))
                        self.wall_states[tuple(sorted(wall_pos))] = "okay"

                if wall_value & 1:  # Pared izquierda (bit 0)
                    if j > 0:
                        wall_pos = ((i, j), (i, j - 1))
                        self.wall_states[tuple(sorted(wall_pos))] = "okay"

    def place_poi(self, poi_data):
        """Coloca POIs en posiciones específicas respetando el número por tipo y actualiza las variables."""

        # Crear lista de tipos de POIs respetando los contadores.
        poi_types = (
            [3] * self.poi_false_alarm +  # POIs falsos
            [4] * self.poi_real_victim    # POIs reales
        )

        # Barajar aleatoriamente los tipos de POIs.
        self.random.shuffle(poi_types)

        # Seleccionar solo los necesarios para las posiciones disponibles.
        selected_poi_types = poi_types[:len(poi_data)]

        # Asignar tipos de POIs a las posiciones disponibles.
        for (x, y, poi_type), poi_val in zip(poi_data, selected_poi_types):
            # Ajustar índices para comenzar desde 0
            adjusted_x, adjusted_y = x - 1, y - 1

            # Validar que las posiciones ajustadas estén dentro de los límites.
            if 0 <= adjusted_x < self.height and 0 <= adjusted_y < self.width:
                # Determinar el valor de POI basado en tipo ('v' -> verdadero, 'f' -> falso).
                value = 4 if poi_type == 'v' else 3
                self.poi_placement[adjusted_x][adjusted_y] = value

                # Inicializar estado como "cerrado".
                self.poi_states[(adjusted_x, adjusted_y)] = "closed"
                self.poi_in_building += 1

    def print_poi_info(self):
        """Imprime información sobre los POIs restantes."""
        print(f"Falsas alarmas restantes: {self.poi_false_alarm}")
        print(f"Víctimas reales restantes: {self.poi_real_victim}")
        print(f"Total POIs restantes: {self.poi_total_count}")
        print(f"Total POIs en edificio: {self.poi_in_building}")

    def place_goo(self, goo_data):
        """Coloca goo en posiciones específicas basadas en los datos proporcionados con ajuste de índice."""
        for x, y in goo_data:
            # Ajustar índices para comenzar desde 0
            adjusted_x, adjusted_y = x - 1, y - 1

            # Asegúrate de que las posiciones ajustadas estén dentro de los límites.
            if 0 <= adjusted_x < self.height and 0 <= adjusted_y < self.width:
                if self.threat_markers[adjusted_x][adjusted_y] == 0:  # Solo colocar si la celda está vacía
                    self.threat_markers[adjusted_x][adjusted_y] = 2  # Representar el goo con un valor de 2
                    self.current_threat_markers += 1  # Incrementa el contador de fichas en el tablero
                    print(f"Goo colocado en ({adjusted_x}, {adjusted_y}). Total fichas: {self.current_threat_markers}")


    def place_doors(self, doors_data):
        """Coloca puertas en posiciones específicas basadas en los datos proporcionados con ajuste de índice."""
        for row1, col1, row2, col2 in doors_data:

            # Ajustar índices para comenzar desde 0
            adjusted_row1, adjusted_col1 = row1 - 1, col1 - 1
            adjusted_row2, adjusted_col2 = row2 - 1, col2 - 1

            # Validar que las posiciones estén dentro de los límites
            if (
                0 <= adjusted_row1 < self.height and
                0 <= adjusted_col1 < self.width and
                0 <= adjusted_row2 < self.height and
                0 <= adjusted_col2 < self.width
            ):
                # Marcar las puertas en la matriz doors
                if adjusted_row1 == adjusted_row2:  # Puerta entre columnas en la misma fila
                    self.doors[adjusted_row1, adjusted_col1] |= 4
                    self.doors[adjusted_row2, adjusted_col2] |= 1
                elif adjusted_col1 == adjusted_col2:  # Puerta entre filas en la misma columna
                    self.doors[adjusted_row1, adjusted_col1] |= 2
                    self.doors[adjusted_row2, adjusted_col2] |= 8

                # Crear una tupla de posiciones ordenadas
                pos1 = (adjusted_row1, adjusted_col1)
                pos2 = (adjusted_row2, adjusted_col2)
                door = tuple(sorted([pos1, pos2]))

                # Inicializar el estado de la puerta como "closed"
                self.door_states[door] = "closed"

                print(f"Puerta colocada entre {door} - Estado: closed")

    def print_door_info(self):
        """Imprime información sobre los estados de las puertas."""
        print("\nInformación de las puertas:")
        for door, state in self.door_states.items():
            print(f"Puerta {door} - Estado: {state}")


    def place_start_point(self, entry_points_data):
        """Coloca puntos de entrada en posiciones específicas y las guarda en una lista."""
        self.entry_points = []  # Lista para almacenar puntos de entrada
        for x, y in entry_points_data:
            # Ajustar índices para comenzar desde 0
            adjusted_x, adjusted_y = x - 1, y - 1
            # Asegúrate de que las posiciones ajustadas estén dentro de los límites
            if 0 <= adjusted_x < self.height and 0 <= adjusted_y < self.width:
                self.entry_points_location[adjusted_x][adjusted_y] = 16  # Representar el punto de entrada con un valor de 16
                self.entry_points.append((adjusted_x, adjusted_y))  # Agregar punto de entrada a la lista

    def replenish_pois(self):
        """Repone los POIs en el edificio."""
        print("\n[Replenish POIs] Iniciando reposición de POIs...")
        print(f"Estado inicial: POIs en edificio = {self.poi_in_building}, Falsas alarmas = {self.poi_false_alarm}, Víctimas reales = {self.poi_real_victim}, Total POIs restantes = {self.poi_total_count}")

        while self.poi_in_building < min(3, self.poi_total_count):
            # Verificar si quedan POIs disponibles
            if self.poi_false_alarm == 0 and self.poi_real_victim == 0:
                print("No quedan más POIs para colocar.")
                break

            # Elegir un espacio aleatorio en el grid
            x = self.random.randint(0, self.height - 1)
            y = self.random.randint(0, self.width - 1)
            print(f"Intentando colocar un POI en la celda: ({x}, {y})")

            # Verificar las condiciones para colocar un POI
            if self.poi_placement[x, y] == 0:
                print(f"La celda ({x}, {y}) está vacía. Continuando...")

                if self.threat_markers[x, y] in [2, 1]:
                    print(f"Marcador de amenaza detectado en ({x}, {y}). Eliminando marcador...")
                    self.threat_markers[x, y] = 0
                    self.current_threat_markers -= 1  # Decrementar el contador de threat markers
                    print(f"Marcadores de amenaza restantes: {self.current_threat_markers}")

                # Elegir el nuevo POI (aleatoriamente entre 3 y 4)
                poi_types = (
                    [3] * self.poi_false_alarm +  # POIs falsos
                    [4] * self.poi_real_victim    # POIs reales
                )

                # Barajar aleatoriamente los tipos de POIs
                new_poi = self.random.choice(poi_types)
                print(f"Nuevo POI seleccionado: {'Falsa Alarma' if new_poi == 3 else 'Víctima'}")

                # Verificar si hay un agente en la celda
                cell_agents = self.grid.get_cell_list_contents((x, y))
                employee_present = any(isinstance(agent, EmployeeAgent) for agent in cell_agents)

                if employee_present:
                    self.poi_placement[x, y] = new_poi
                    self.poi_in_building += 1
                    print(f"Agente presente en ({x}, {y}). Revelando POI inmediatamente...")
                    if new_poi == 3:  # Falsa alarma
                        print(f"POI en ({x}, {y}) era falsa alarma. Eliminando.")
                        self.poi_placement[x, y] = 0
                        self.poi_false_alarm -= 1
                        self.poi_total_count -= 1
                        self.poi_in_building -= 1
                    elif new_poi == 4:  # Víctima
                        print(f"POI en ({x}, {y}) es una víctima.")
                else:
                    # Colocar el nuevo POI en la celda
                    self.poi_placement[x, y] = new_poi
                    print(f"POI colocado en ({x}, {y}): {'Falsa Alarma' if new_poi == 3 else 'Víctima'}")
                    self.poi_in_building += 1

            else:
                print(f"La celda ({x}, {y}) ya tiene un POI. Intentando otra celda...")

        print(f"[Replenish POIs] Finalizado. Estado final: POIs en edificio = {self.poi_in_building}, Falsas alarmas = {self.poi_false_alarm}, Víctimas reales = {self.poi_real_victim}, Total POIs restantes = {self.poi_total_count}\n")

    def can_place_threat_marker(self):
        """
        Verifica si se puede colocar otro threat marker (goo o droplet) en el tablero.
        """
        return self.current_threat_markers <= self.max_threat_markers

    def update_wall_matrix(self, wall_position, state):
        """
        Actualiza la matriz de paredes del modelo para reflejar el estado actual.
        """
        (pos1, pos2) = wall_position
        x1, y1 = pos1
        x2, y2 = pos2

        # Imprimir la matriz de paredes antes de la actualización.
        print("\nMatriz self.walls antes de actualizar:")
        for row in self.walls:
            print(" ".join(format(cell, '04b') for cell in row))

        if state == "destroyed":
            # Determinar la dirección de la pared a eliminar
            if x1 == x2:  # Pared horizontal
                if y1 < y2:  # pos1 está a la izquierda de pos2
                    self.walls[x1, y1] &= ~4  # Elimina la pared derecha (bit 2) de pos1
                    self.walls[x2, y2] &= ~1  # Elimina la pared izquierda (bit 0) de pos2
                else:  # pos1 está a la derecha de pos2
                    self.walls[x1, y1] &= ~1  # Elimina la pared izquierda (bit 0) de pos1
                    self.walls[x2, y2] &= ~4  # Elimina la pared derecha (bit 2) de pos2
            elif y1 == y2:  # Pared vertical
                if x1 < x2:  # pos1 está arriba de pos2
                    self.walls[x1, y1] &= ~2  # Elimina la pared abajo (bit 1) de pos1
                    self.walls[x2, y2] &= ~8  # Elimina la pared arriba (bit 3) de pos2
                else:  # pos1 está abajo de pos2
                    self.walls[x1, y1] &= ~8  # Elimina la pared arriba (bit 3) de pos1
                    self.walls[x2, y2] &= ~2  # Elimina la pared abajo (bit 1) de pos2

        # Imprimir la matriz de paredes después de la actualización
        print("\nMatriz self.walls después de actualizar:")
        for row in self.walls:
            print(" ".join(format(cell, '04b') for cell in row))

    def update_door_matrix(self, door_position, state):
        """
        Actualiza la matriz de puertas del modelo para reflejar el estado actual.
        """
        (pos1, pos2) = door_position
        x1, y1 = pos1
        x2, y2 = pos2

        # Imprimir la matriz de puertas antes de la actualización
        print("\nMatriz self.doors antes de actualizar:")
        for row in self.doors:
            print(" ".join(format(cell, '04b') for cell in row))

        if state == "removed":
            # Determinar la dirección de la puerta a eliminar
            if x1 == x2:  # Puerta horizontal
                if y1 < y2:  # pos1 está a la izquierda de pos2
                    self.doors[x1, y1] &= ~4  # Elimina el bit derecho (bit 2) de pos1
                    self.doors[x2, y2] &= ~1  # Elimina el bit izquierdo (bit 0) de pos2
                else:  # pos1 está a la derecha de pos2
                    self.doors[x1, y1] &= ~1  # Elimina el bit izquierdo (bit 0) de pos1
                    self.doors[x2, y2] &= ~4  # Elimina el bit derecho (bit 2) de pos2
            elif y1 == y2:  # Puerta vertical
                if x1 < x2:  # pos1 está arriba de pos2
                    self.doors[x1, y1] &= ~2  # Elimina el bit abajo (bit 1) de pos1
                    self.doors[x2, y2] &= ~8  # Elimina el bit arriba (bit 3) de pos2
                else:  # pos1 está abajo de pos2
                    self.doors[x1, y1] &= ~8  # Elimina el bit arriba (bit 3) de pos1
                    self.doors[x2, y2] &= ~2  # Elimina el bit abajo (bit 1) de pos2

        # Imprimir la matriz de puertas después de la actualización
        print("\nMatriz self.doors después de actualizar:")
        for row in self.doors:
            print(" ".join(format(cell, '04b') for cell in row))

    def advance_goo(self):
        """Avanza la cantidad de los marcadores de riesgo."""

        # Verificar si quedan threat markers disponibles
        if not self.can_place_threat_marker():
            print("No se pueden avanzar más threat markers. Límite alcanzado.")
            return

        # Print the threat_markers matrix before advancing goo
        print("\nMatriz threat_markers antes de advance_goo:")
        for row in self.threat_markers:
            print(" ".join(map(str, row)))

        # Obtener una lista de todas las posiciones en threat_markers
        threat_markers_positions = [(x, y) for x in range(self.height) for y in range(self.width)]

        # Elegir una posición aleatoria
        target_position = self.random.choice(threat_markers_positions)
        x, y = target_position

        # Verificar si la celda es el lootbug nest (0, 0)
        if (x, y) == (0, 0):
            print(f"No se puede colocar goo ni droplets en el lootbug nest ({x}, {y}).")
            return

        # Verificar si la celda está vacía
        if self.threat_markers[x, y] == 0:

            # Obtener las celdas adyacentes (vecindad de Moore)
            neighbors = self.grid.get_neighborhood((x, y), moore=True, include_center=False)

            # Verificar si no hay goo en las celdas adyacentes
            no_goo_nearby = all(
                self.threat_markers[nx, ny] != 2 for nx, ny in neighbors if 0 <= nx < self.height and 0 <= ny < self.width
            )

            if no_goo_nearby:
                # Colocar droplet en la celda seleccionada
                self.threat_markers[x, y] = 1
                self.current_threat_markers += 1
                print(f"Advance: Se colocó un droplet en la celda ({x}, {y}).")
            elif not no_goo_nearby:
                # Colocar goo en la celda seleccionada
                self.threat_markers[x, y] = 2
                self.current_threat_markers += 1
                print(f"Advance: Se colocó goo en la celda ({x}, {y}).")

        # Si la celda ya contiene un droplet
        elif self.threat_markers[x, y] == 1:
            self.threat_markers[x, y] = 2  # Colocar goo
            print(f"Advance: El droplet en la celda ({x}, {y}) se convirtió en goo.")

        # Si la celda ya contiene goo
        elif self.threat_markers[x, y] == 2:
            print(f"Goo detectado en la celda ({x}, {y}). Llamando a la función de explosión...")
            self.explosion(x, y)

        # Print the threat_markers matrix after advancing goo
        print("\nMatriz threat_markers después de advance_goo / explosion:")
        for row in self.threat_markers:
            print(" ".join(map(str, row)))

    def explosion(self, x, y):
        """Genera explosión de goo, afectando celdas adyacentes."""

        # Verificar si quedan threat markers disponibles
        if not self.can_place_threat_marker():
            print("No se pueden avanzar más threat markers. Límite alcanzado.")
            return

        print(f"Explosión iniciada en la celda ({x}, {y}).")

        # Obtener las celdas adyacentes (vecindad de Von Neumann)
        neighbors = self.grid.get_neighborhood((x, y), moore=False, include_center=False)

        for nx, ny in neighbors:
            print(f"Evaluando celda adyacente ({nx}, {ny}).")
            # Verificar si la celda está dentro de los límites
            if 0 <= nx < self.height and 0 <= ny < self.width:

                # Verificar si es el lootbug nest
                if (nx, ny) == (0, 0):
                    print(f"No se puede propagar goo ni dañar paredes hacia el lootbug nest ({nx}, {ny}).")
                    continue

                # Eliminar puertas entre la celda actual y la vecina
                door = tuple(sorted([(x, y), (nx, ny)]))
                if door in self.door_states:
                    if self.door_states[door] == "closed":
                        print(f"Puerta cerrada entre ({x}, {y}) y ({nx}, {ny}). La explosión se detiene aquí.")
                        self.door_states[door] = "removed"
                        self.update_door_matrix(door, "removed")
                        continue # Detener la propagación en esta dirección
                    elif self.door_states[door] == "open":
                        print(f"Puerta abierta entre ({x}, {y}) y ({nx}, {ny}). Continuando explosión.")
                        self.door_states[door] = "removed"
                        self.update_door_matrix(door, "removed")

                # Identificar y dañar paredes entre la celda actual y la vecina
                wall = tuple(sorted([(x, y), (nx, ny)]))
                if wall in self.wall_states:
                    current_state = self.wall_states[wall]
                    if current_state == "okay":
                        self.wall_states[wall] = "damaged"
                        self.damage_counter -= 1
                        print(f" Explosion: Pared dañada entre ({x}, {y}) y ({nx}, {ny}).")
                        continue
                    elif current_state == "damaged":
                        self.wall_states[wall] = "destroyed"
                        self.damage_counter -= 1
                        print(f" Explosion: Pared destruida entre ({x}, {y}) y ({nx}, {ny}).")

                        # Actualizar la matriz de paredes para reflejar el estado destruido
                        self.update_wall_matrix(wall, "destroyed")
                        continue  # Detener la propagación en esta dirección


                # Si la celda contiene goo, comenzar shockwave.
                if self.threat_markers[nx, ny] == 2:
                    dx, dy = nx - x, ny - y  # Calcular la dirección
                    print(f"Goo detectado en la celda adyacente ({nx}, {ny}). Llamando a la función shockwave() en dirección ({dx}, {dy})...")
                    self.shockwave(nx, ny, direction=(dx, dy))
                    continue

                # Si la celda contiene un droplet, eliminarlo.
                if self.threat_markers[nx, ny] == 1:
                    self.threat_markers[nx, ny] = 0
                    self.current_threat_markers -= 1
                    print(f" Explosion: Droplet eliminado en la celda ({nx}, {ny}).")


                # Si la celda está vacía o contenía un droplet, colocar goo.
                if self.threat_markers[nx, ny] == 0:
                    self.threat_markers[nx, ny] = 2
                    self.current_threat_markers += 1
                    print(f" Explosion: Se colocó goo en la celda ({nx}, {ny}).")

    def shockwave(self, x, y, direction):
        """Propaga una onda expansiva desde la celda especificada."""

        # Verificar si quedan threat markers disponibles
        if not self.can_place_threat_marker():
            print("No se pueden avanzar más threat markers. Límite alcanzado.")
            return

        print(f"Shockwave iniciada en la celda ({x}, {y}) en dirección {direction}.")

        dx, dy = direction
        current_x, current_y = x, y
        while True:
            # Avanzar en la dirección especificada
            current_x += dx
            current_y += dy

            # Imprimir la celda actual por la que pasa la shockwave
            print(f"Shockwave pasando por la celda ({current_x}, {current_y}).")

            # Verificar si está fuera de los límites del grid
            if not (0 <= current_x < self.height and 0 <= current_y < self.width):
                break

            # Verificar si es el lootbug nest
            if (current_x, current_y) == (0, 0):
                print(f"La onda expansiva no afecta el lootbug nest ({current_x}, {current_y}).")
                break

            # Verificar si hay una puerta
            door = tuple(sorted([((current_x - dx), (current_y - dy)), (current_x, current_y)]))
            if door in self.door_states:
                if self.door_states[door] == "closed":
                    print(f" Shockwave: Puerta cerrada. Eliminando puerta entre {door[0]} y {door[1]}.")
                    self.door_states[door] = "removed"
                    self.update_door_matrix(door, "removed")
                    break
                elif self.door_states[door] == "open":
                    print(f" Shockwave: Puerta abierta. Eliminando puerta entre {door[0]} y {door[1]}.")
                    self.door_states[door] = "removed"
                    self.update_door_matrix(door, "removed")

            # Verificar si hay una pared y/o puerta
            wall = tuple(sorted([((current_x - dx), (current_y - dy)), (current_x, current_y)]))
            if wall in self.wall_states:
                current_state = self.wall_states[wall]
                if current_state == "okay":
                    self.wall_states[wall] = "damaged"
                    self.damage_counter -= 1
                    print(f" Shockwave: Pared dañada entre ({current_x - dx}, {current_y - dy}) y ({current_x}, {current_y}).")
                    break  # Detener la propagación en esta dirección
                elif current_state == "damaged":
                    self.wall_states[wall] = "destroyed"
                    self.damage_counter -= 1
                    print(f" Shockwave: Pared destruida entre ({current_x - dx}, {current_y - dy}) y ({current_x}, {current_y}).")
                    self.update_wall_matrix(wall, "destroyed")
                    break  # La onda no puede pasar paredes destruidas

            # Verificar si es una celda con droplets
            if self.threat_markers[current_x, current_y] == 1:
                print(f" Shockwave: Goo colocado en celda con droplets ({current_x}, {current_y}).")
                self.threat_markers[current_x, current_y] = 2
                break

            # Si la celda está vacía, colocar goo
            if self.threat_markers[current_x, current_y] == 0:
                print(f" Shockwave: Goo colocado en celda vacía ({current_x}, {current_y}).")
                self.threat_markers[current_x, current_y] = 2
                self.current_threat_markers += 1
                break

        # Print the threat_markers matrix after advancing goo
        print("\nMatriz threat_markers después de shockwave:")
        for row in self.threat_markers:
            print(" ".join(map(str, row)))

    def check_secondary_effects(self):
        """Revisar los efectos secundarios después del avance de goo."""
        print("Revisando efectos secundarios en el threat grid...")

        # Iterar por todas las celdas de la cuadrícula
        for x in range(self.height):
            for y in range(self.width):
                # Verificar si la celda contiene un droplet
                if self.threat_markers[x, y] == 1:
                    # Obtener las celdas adyacentes (vecindad de Moore)
                    neighbors = self.grid.get_neighborhood((x, y), moore=True, include_center=False)

                    # Verificar si alguna celda adyacente contiene goo
                    goo_nearby = any(
                        self.threat_markers[nx, ny] == 2
                        for nx, ny in neighbors
                        if 0 <= nx < self.height and 0 <= ny < self.width
                    )

                    if goo_nearby:
                        # Cambiar el droplet por goo
                        self.threat_markers[x, y] = 0
                        self.threat_markers[x, y] = 2
                        print(f"Droplet en ({x}, {y}) convertido en goo debido a proximidad.")

    def end_game(self):
        """Verifica las condiciones de victoria o derrota y detiene la simulación si es necesario."""

        # Evitar múltiples llamadas si el juego ya terminó
        if not self.running:
            return

        if self.damage_counter == 0:
            self.collapsed_building = True

        if self.saved_victims == 7:
            print(f"¡Victoria! Se salvaron {self.saved_victims} víctimas en {self.steps} pasos.")
            self.running = False

        elif self.damage_counter == 0 or self.lost_victims == 4:
            if self.damage_counter == 0:
                print(f"¡Derrota! El edificio colapsó después de {self.steps} pasos.")
            elif self.lost_victims == 4:
                print(f"¡Derrota! Se perdieron {self.lost_victims} víctimas en {self.steps} pasos.")
            elif self.poi_total_count == 0:
                print(f"No se logró alcanzar la meta. Se salvaron {self.saved_victims} y se perdieron {self.lost_victims}.")
            self.running = False

    def step(self):
        """
        Ejecuta un paso en la simulación si esta está en ejecución.
        - Incrementa el contador de pasos.
        - Recolecta datos del estado actual de la simulación.
        - Avanza el estado de los agentes programados en el modelo.
        """
        if self.running:
            self.steps += 1
            self.schedule.step()
            self.datacollector.collect(self)

"""#Input"""

input_data_walls = """
1001 1000 1100 1001 1100 1001 1000 1100
0001 0000 0110 0011 0110 0011 0010 0110
0001 0100 1001 1000 1000 1100 1001 1100
0011 0110 0011 0010 0010 0110 0011 0110
1001 1000 1000 1000 1100 1001 1100 1101
0011 0010 0010 0010 0110 0011 0110 0111
"""

matrix_walls = [row.split() for row in input_data_walls.strip().split("\n")]

# ------------------------------------------------------------------------------------------------
input_data_poi = """
2 4 v
5 1 f
5 8 v
"""

# Procesar el texto: Convertir números a enteros, mantener letras como cadenas.
def process_row(row):
    return [int(item) if item.isdigit() else item for item in row.split()]

matrix_poi = [process_row(row) for row in input_data_poi.strip().split("\n")]

# ------------------------------------------------------------------------------------------------

input_data_goo = """
2 2
2 3
3 2
3 3
3 4
3 5
4 4
5 6
5 7
6 6
"""

matrix_goo = [list(map(int, row.split())) for row in input_data_goo.strip().split("\n")]

# ------------------------------------------------------------------------------------------------

input_data_doors = """
1 3 1 4
2 5 2 6
2 8 3 8
3 2 3 3
4 4 5 4
4 6 4 7
6 5 6 6
6 7 6 8
"""

matrix_doors = [list(map(int, row.split())) for row in input_data_doors.strip().split("\n")]

# ------------------------------------------------------------------------------------------------

input_data_entry_points = """
1 6
3 1
4 8
6 3
"""

matrix_entry_points = [list(map(int, row.split())) for row in input_data_entry_points.strip().split("\n")]

# ------------------------------------------------------------------------------------------------

"""#Run & Test"""

# Crear una instancia del modelo
model = ModeloEdificio(matrix_walls, matrix_poi, matrix_goo, matrix_doors, matrix_entry_points)

# Obtener el estado inicial del grid
initial_grid_agents = get_grid(model)
initial_grid_doors_entries = get_grid_doors_entries(model)
initial_grid_poi = get_grid_poi(model)
initial_grid_threat_markers = get_grid_threat_markers(model)
initial_grid_walls = get_grid_walls(model)

# --------------------------------------------------------------------------------------------------------

# Imprimir la matriz del grid con formato
print("\nEstado inicial de los agentes:")
print(np.array2string(initial_grid_agents, formatter={'float_kind': lambda x: "%.1f" % x}))

# --------------------------------------------------------------------------------------------------------

# Imprimir la matriz del grid con formato
print("\nEstado inicial de las puertas y salidas:")
print(np.array2string(initial_grid_doors_entries, formatter={'float_kind': lambda x: "%.1f" % x}))

# Imprimir los puntos de entrada
print("\nPuntos de entrada:")
for entry_point in model.entry_points:
    print(f"Punto de entrada en posición: {entry_point}")

# Imprimir matriz de puertas
print("\nMatriz de puertas (doors):")
for i in range(model.height):
    print([format(model.doors[i, j], '04b') for j in range(model.width)])

model.print_door_info()

# --------------------------------------------------------------------------------------------------------

# Imprimir la matriz del grid con formato
print("\nEstado inicial de los pois:")
print(np.array2string(initial_grid_poi, formatter={'float_kind': lambda x: "%.1f" % x}))

# Imprimir los POIs con su posición y estado
print("\nPOIs con sus posiciones y estados:")
for position, state in model.poi_states.items():
    x, y = position
    poi_type = model.poi_placement[x][y]  # Obtener el tipo de POI desde la matriz
    print(f"POI en posición {position} - Tipo: {int(poi_type)} - Estado: {state}")

model.print_poi_info()

# --------------------------------------------------------------------------------------------------------

# Imprimir la matriz del grid con formato
print("\nEstado inicial de los threat markers:")
print(np.array2string(initial_grid_threat_markers, formatter={'float_kind': lambda x: "%.1f" % x}))
# --------------------------------------------------------------------------------------------------------

# Imprimir la matriz del grid con formato
print("\nEstado inicial de las paredes:")
print(np.array2string(initial_grid_walls, formatter={'float_kind': lambda x: "%.1f" % x}))

# Obtener la matriz de paredes
print("\nMatriz de paredes (walls):")
for i in range(model.height):
    row = [format(model.walls[i, j], '04b') for j in range(model.width)]  # Convertir cada valor a binario de 4 dígitos
    print(" ".join(row))

print("\n")

# Define el máximo de pasos para la simulación
MAX_STEPS = 1000

# Ejecutar el modelo
while model.running and model.steps < MAX_STEPS:
    model.step()

# Al finalizar la simulación, imprime los resultados
print("\nResultados finales de la simulación:")
print(f"Víctimas salvadas: {model.saved_victims}")
print(f"Víctimas perdidas: {model.lost_victims}")

# Recupera todos los datos recolectados del modelo en un DataFrame
all_grids = model.datacollector.get_model_vars_dataframe()

# Muestra las primeras 5 filas del DataFrame
all_grids.head(5)

# Importar bibliotecas necesarias
import matplotlib.pyplot as plt
from matplotlib.animation import FuncAnimation
from matplotlib.colors import ListedColormap, BoundaryNorm

# Crear un colormap personalizado
colors = [
    "white",     # Espacio vacío
    "orange",       # Threatmarkers (fuego o goo)
    "darkblue",     # POI
    "darkblue",
    "purple",    # Agentes
]
cmap = ListedColormap(colors)

# Extraer los grids correspondientes a POIs y agentes
poi_grids = all_grids["Grid 3 POI"].tolist()
agent_grids = all_grids["Grid 5 Agents"].tolist()
fire_grids = all_grids["Grid 4 Threatmarkers"].tolist()

# Combinar los grids (sumar sus valores para un solo grid)
combined_grids = [
    poi_grid + agent_grid + fire_grid
    for poi_grid, agent_grid, fire_grid in zip(poi_grids, agent_grids, fire_grids)
]

# Configurar la figura para la animación
fig, axs = plt.subplots(figsize=(5, 5))
axs.set_xticks([])
axs.set_yticks([])

# Inicializar el primer frame con el grid combinado
patch = axs.imshow(combined_grids[0], cmap=cmap)

# Definir la función de actualización
def animate(i):
    patch.set_data(combined_grids[i])  # Actualizar el grid en cada frame
    return patch,

# Crear la animación
anim = FuncAnimation(fig, animate, frames=len(combined_grids), blit=True)

anim

"""# Dibujo de paredes y puertas"""

import matplotlib.pyplot as plt
import numpy as np

def draw_walls_and_doors(input_walls, input_doors):
    # Convertir las matrices de entrada en listas
    walls = [line.split() for line in input_walls.strip().split("\n")]
    doors = [
        [int(value, 2) for value in line.strip("[]").replace(",", "").split()]
        for line in input_doors.strip().split("\n")
    ]
    rows, cols = len(walls), len(walls[0])

    # Crear la figura
    fig, ax = plt.subplots(figsize=(8, 6))
    ax.set_xlim(0, cols)
    ax.set_ylim(0, rows)
    ax.set_aspect('equal')
    ax.invert_yaxis()  # Invertir el eje Y para que (0,0) sea la esquina superior izquierda

    # Dibujar paredes y puertas
    for i in range(rows):
        for j in range(cols):
            wall_value = int(walls[i][j], 2)  # Convertir paredes de binario a decimal
            door_value = doors[i][j]  # Los valores ya están convertidos a enteros
            x, y = j, i  # Coordenadas de la celda

            # Dibujar paredes sólidas
            if wall_value & 8:  # Pared arriba
                ax.plot([x, x + 1], [y, y], 'k-', lw=2)
            if wall_value & 4:  # Pared derecha
                ax.plot([x + 1, x + 1], [y, y + 1], 'k-', lw=2)
            if wall_value & 2:  # Pared abajo
                ax.plot([x, x + 1], [y + 1, y + 1], 'k-', lw=2)
            if wall_value & 1:  # Pared izquierda
                ax.plot([x, x], [y, y + 1], 'k-', lw=2)

            # Dibujar puertas (líneas punteadas)
            if door_value & 8:  # Puerta arriba
                ax.plot([x, x + 1], [y, y], 'y--', lw=2)
            if door_value & 4:  # Puerta derecha
                ax.plot([x + 1, x + 1], [y, y + 1], 'y--', lw=2)
            if door_value & 2:  # Puerta abajo
                ax.plot([x, x + 1], [y + 1, y + 1], 'y--', lw=2)
            if door_value & 1:  # Puerta izquierda
                ax.plot([x, x], [y, y + 1], 'y--', lw=2)

    # Configuración del gráfico
    ax.set_xticks(np.arange(0, cols + 1, 1))
    ax.set_yticks(np.arange(0, rows + 1, 1))
    ax.grid(color="gray", linestyle="--", linewidth=0.5)
    plt.title("Mapa con Paredes y Puertas")
    plt.show()


input_data_walls = """
1001 1000 1100 1001 1100 1001 1000 1100
0001 0000 0110 0011 0110 0011 0010 0110
0001 0100 1001 1000 1000 1100 1001 1100
0011 0110 0011 0010 0010 0110 0011 0110
1001 1000 1000 1000 1100 1001 1100 1101
0011 0010 0010 0010 0110 0011 0110 0111
"""

input_data_doors = """
0000 0000 0100 0001 0000 0000 0000 0000
0000 0000 0000 0000 0100 0001 0000 0010
0000 0100 0001 0000 0000 0000 0000 1000
0000 0000 0000 0010 0000 0100 0001 0000
0000 0000 0000 1000 0000 0000 0000 0000
0000 0000 0000 0000 0100 0001 0100 0001
"""

# Dibujar el mapa
draw_walls_and_doors(input_data_walls, input_data_doors)

"""# Análisis de eficiencia"""

from mesa.batchrunner import batch_run


params = {
    "wall_data": [matrix_walls],          # Matriz de paredes
    "poi_data": [matrix_poi],            # Matriz de POIs
    "goo_data": [matrix_goo],            # Matriz de elementos 'goo'
    "doors_data": [matrix_doors],        # Matriz de puertas
    "entry_points_data": [matrix_entry_points]  # Matriz de puntos de entrada
}

STEPS = 500
ITERATIONS = 50

results = batch_run(
    ModeloEdificio,
    parameters=params,
    iterations=ITERATIONS,
    max_steps=STEPS,
    number_processes=1,
    data_collection_period=1,
    display_progress=True
)

df = pd.DataFrame(results)

# Agrupar por RunId y obtener el último paso para cada ejecución
df_last_step = df.sort_values('Step').groupby('RunId').last().reset_index()

# Eliminar las columnas innecesarias
df_analysis = df_last_step.drop(
    ['Step', 'wall_data', 'poi_data', 'goo_data', 'doors_data', 'entry_points_data',
    'Grid 1 Puertas y salidas', 'Grid 2 Paredes', 'Grid 3 POI', 'Grid 4 Threatmarkers', 'Grid 5 Agents'],
    axis=1
)

# Mostrar los primeros 12 registros para verificar
df_analysis.head(20)

# Cálculo de los promedios
promedios = {
    "Promedio de Steps": df_analysis["Steps"].mean(),
    "Promedio de víctimas salvadas": df_analysis["Victimas salvadas"].mean(),
    "Promedio de víctimas perdidas": df_analysis["Victimas perdidas"].mean(),
    "Porcentaje de edificios colapsados": df_analysis["Edificio colapsado"].mean() * 100
}

# Mostrar promedios
print("Promedios de las métricas:")
for key, value in promedios.items():
    print(f"{key}: {value:.2f}")

# Gráfica: Distribución de resultados (colapsos, víctimas salvadas y perdidas)
df_analysis["Resultado"] = df_analysis.apply(
    lambda row: "Colapso" if row["Edificio colapsado"] else
    "Perdió 4 víctimas" if row["Victimas perdidas"] >= 4 else
    "Salvó 7 víctimas" if row["Victimas salvadas"] >= 7 else
    "Otros",
    axis=1
)

result_counts = df_analysis["Resultado"].value_counts()

plt.figure(figsize=(10, 6))
result_counts.plot(kind='bar', color=["#003f5c", "#2f4b7c", "#665191", "#a05195"])
plt.title("Distribución de resultados de las simulaciones")
plt.xlabel("Resultado")
plt.ylabel("Cantidad de corridas")
plt.xticks(rotation=45)
plt.grid(axis='y', linestyle='--', alpha=0.7)
plt.tight_layout()
plt.show()

# Grafica de promedio de victimas salvadas vs victimas perdidas
plt.figure(figsize=(10, 6))
plt.bar(["Víctimas salvadas", "Víctimas perdidas"],
        [promedios["Promedio de víctimas salvadas"], promedios["Promedio de víctimas perdidas"]],
        color=["#003f5c", "#2f4b7c"])
plt.title("Promedio de víctimas salvadas vs. víctimas perdidas")
plt.ylabel("Promedio")
plt.grid(axis='y', linestyle='--', alpha=0.7)
plt.tight_layout()
plt.show()


# Crear el json
import json

def run_model_and_save_to_json(steps: int, model_instance: ModeloEdificio, output_file: str):
    """
    Ejecuta el modelo y guarda los datos recolectados en un archivo JSON.

    Args:
        steps (int): Número de pasos para ejecutar el modelo.
        model_instance (ModeloEdificio): Instancia del modelo del edificio.
        output_file (str): Nombre del archivo donde se guardará el JSON.
    """
    # Ejecutar el modelo por el número de pasos especificado
    for step in range(steps):
        model_instance.step()  # Avanzar un paso en la simulación
        print(f"Simulación paso {step + 1} completada.")

    # Obtener los datos recolectados del DataCollector
    collected_data = model_instance.datacollector.get_model_vars_dataframe()

    # Formatear los datos en una estructura adecuada para JSON
    json_data = {
        "simulation_data": [],
        "summary": {
            "steps": steps,
            "collapsed_building": model_instance.collapsed_building,
            "saved_victims": model_instance.saved_victims,
            "lost_victims": model_instance.lost_victims,
        }
    }

    for index, row in collected_data.iterrows():
        json_data["simulation_data"].append({
            "step": row["Steps"],
            "grid_doors_entries": row["Grid 1 Puertas y salidas"],
            "grid_walls": row["Grid 2 Paredes"],
            "grid_poi": row["Grid 3 POI"],
            "grid_threat_markers": row["Grid 4 Threatmarkers"],
            "grid_agents": row["Grid 5 Agents"],
            "collapsed_building": row["Edificio colapsado"],
            "saved_victims": row["Victimas salvadas"],
            "lost_victims": row["Victimas perdidas"],
        })

    # Asegurarse de convertir los arreglos Numpy a listas antes de serializarlos
    json_data["simulation_data"] = [{
        "step": row["Steps"],
        "grid_doors_entries": np.array(row["Grid 1 Puertas y salidas"]).tolist(),
        "grid_walls": np.array(row["Grid 2 Paredes"]).tolist(),
        "grid_poi": np.array(row["Grid 3 POI"]).tolist(),
        "grid_threat_markers": np.array(row["Grid 4 Threatmarkers"]).tolist(),
        "grid_agents": np.array(row["Grid 5 Agents"]).tolist(),
        "collapsed_building": row["Edificio colapsado"],
        "saved_victims": row["Victimas salvadas"],
        "lost_victims": row["Victimas perdidas"],
    } for index, row in collected_data.iterrows()]

    # Guardar los datos como un archivo JSON
    with open(output_file, 'w') as outfile:
        json.dump(json_data, outfile, indent=4)
    print(f"Datos de simulación guardados en {output_file}.")



# Ejemplo de uso
if __name__ == "__main__":
    # Crear una instancia del modelo con datos iniciales
    wall_data = matrix_walls  # Datos de paredes
    poi_data = matrix_poi  # Datos de puntos de interés
    goo_data = matrix_goo  # Datos de goo
    doors_data = matrix_doors  # Datos de puertas
    entry_points_data = matrix_entry_points  # Puntos de entrada

    # Instanciar el modelo
    modelo = ModeloEdificio(wall_data, poi_data, goo_data, doors_data, entry_points_data)

    # Ejecutar el modelo y guardar los datos
    run_model_and_save_to_json(steps=100, model_instance=modelo, output_file="simulation_output.json")